---
title: 'TryHackMe: Complete Beginner'
date: 2021-10-03 05:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2021-10-03-tryhackme-complete-beginner.html
author: 100007
---

<h1 id="tryhackme-complete-beginner">TryHackMe: Complete Beginner</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2021-10-03</p>
<h2 id="network-services">Network Services</h2>
<h3 id="understanding-nfs">Understanding NFS</h3>
<p>NFS is part of the large family of local and network protocols that can be classified as “remote procedure calls” (RPCs).</p>
<p>NFS file calls always include:</p>
<ul>
<li>The file handle (unique ID, also applies to directories)</li>
<li>The file name</li>
<li>The connecting user ID</li>
<li>The connecting group ID</li>
</ul>
<p>Access checks are made on both the initial mount (does this user have permission to mount this share?) and on file access (does this user have permission to access this file?).</p>
<p>Windows actually does support NFS.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call (Wikipedia)</a></li>
</ul>
<h3 id="enumerating-nfs">Enumerating NFS</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># List NFS shares.</span>
<span class="c">#</span>
showmount <span class="nt">-e</span> <span class="nv">$SERVER_IP</span>
<span class="c"># Mount an NFS share.</span>
<span class="c">#</span>
mount <span class="nt">-t</span> nfs <span class="k">$&#x007b;</span><span class="nv">SERVER_IP</span><span class="k">&#x007d;</span>:<span class="k">$&#x007b;</span><span class="nv">SHARE_PATH</span><span class="k">&#x007d;</span> <span class="se">\</span>
<span class="nv">$LOCAL_MOUNT_DIR</span> <span class="nt">-nolock</span>
</code></pre></div></div>
<p>All versions of NFS use port 2049 to transfer data; NFSv1 - NFSv3 also depended on the “portmapper” service running on port 111, but this requirement was removed in NFSv4.</p>
<ul>
<li><a href="https://racinpaper.com/auto-racing/what-is-nfs-port-number-in-linux.html">What is NFS port number in Linux?</a></li>
</ul>
<h3 id="exploiting-nfs">Exploiting NFS</h3>
<p>By default NFS shares have “root squashing” turned on — attempts to connect as root are assigned to the least-privileged user nfsnobody. But if this is turned off, then it’s possible to set the SUID bit on a file.</p>
<p>NOTE: I don’t see any way to identify that root squashing is disabled from the NMAP scan, so I think we’re just having to take it on faith that it is here. Either that, or this is just one of those “throw spaghetti against the wall and see what happens” times that I’ve run into before in online training CTFs (<em>cough</em> Bandit <em>cough</em>).</p>
<p>So the idea here is:</p>
<ul>
<li>Gain access to the user’s home directory via NFS.</li>
<li>Get their SSH key.</li>
<li>Log in as the user over SSH.</li>
<li>Copy the system bash executable to their home directory (<code class="language-plaintext highlighter-rouge">cp $(which bash) ~/.bash</code>).</li>
<li>Use your <em>system</em> tools to change the owner of the copied executable to root and set the SUID bit (<code class="language-plaintext highlighter-rouge">sudo chown root.root $LOCAL_MOUNT_DIR/cappucino/.bash &amp;&amp; sudo chmow +s $LOCAL_MOUNT_DIR/cappucino/.bash</code>). The magic of NFS will translate the operation as root on our local machine to an operation as root on the remote machine (assuming that root squashing is disabled, which it is in the TryHackMe demo).</li>
<li>Run the SUID bash executable (in the SSH session) using to become root (<code class="language-plaintext highlighter-rouge">~/.bash -p</code>).</li>
<li>Profit!</li>
</ul>
<p>The -p flag tells bash to not drop privileges (otherwise we won’t <em>actually</em> get a root shell).</p>
<p>Note that this is a little bit different than the procedure outlined in the actual TryHackMe “room”, in that I’m copying the system executable rather than downloading a compatible executable from some random GitHub repo. Seems better to live off the land, no?</p>
<p>Sometimes you need to unmount an unresponsive NFS share (for example, if you let a TryHackMe box expire while you still have an active mount). Use umount’s -f flag to force the unmount in this situation.</p>
<ul>
<li><a href="https://cardboard-iguana.com/notes/overthewire-bandit.html">OverTheWire: Bandit</a></li>
</ul>
<h3 id="enumerating-smtp">Enumerating SMTP</h3>
<p>SMTP user enumeration uses a combination of the VRFY (verify user/list), EXPN (expand user/list aliases), and RCPT TO (receipt destination).</p>
<p>Instead of (just) using nmap this time, we’re going to layer in the Metasploit smtp_version and smtp_enum modules!</p>
<p>Basic Metasploit flow:</p>
<ul>
<li><code class="language-plaintext highlighter-rouge">use $MODULE_NAME</code></li>
<li><code class="language-plaintext highlighter-rouge">set $OPTIONS</code></li>
<li><code class="language-plaintext highlighter-rouge">run</code></li>
</ul>
<h3 id="exploiting-smtp">Exploiting SMTP</h3>
<p>Now we’re going to use Hydra to try to brute-force an SSH password. This looks a lot like using Hydra to brute-force an FTP password.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hydra <span class="nt">-t</span> 4 <span class="nt">-l</span> <span class="nv">$USER_NAME</span> <span class="nt">-P</span> <span class="nv">$WORDLIST</span> <span class="se">\</span>
<span class="nt">-vV</span> <span class="nv">$TARGET_IP_ADDRESS</span> ssh
</code></pre></div></div>
<p>The -t flag specifies the number of threads (parallel connection attempts) that Hydra should make at any one time.</p>
<ul>
<li><a href="https://cardboard-iguana.com/log/2021-10-02-tryhackme-complete-beginner.html">2021-10-02 - TryHackMe: Complete Beginner</a></li>
</ul>
<h3 id="understanding-mysql">Understanding MySQL</h3>
<p>Interesting. According to TryHackMe (and a quick search seems to confirm), Facebook uses MySQL as its backend.</p>
<h3 id="enumerating-mysql">Enumerating MySQL</h3>
<p>The Metasploit package for ”enumerating” MySQL data is mysql_sql, but this looks like it’s just a thin wrapper around the mysql client.</p>
<h3 id="exploiting-mysql">Exploiting MySQL</h3>
<p>In PL/SQL, “schema” represents only those parts of a database that are owned (writable?) by a particular user.</p>
<p>The output of the mysql_hashdump Metasploit module is username:password tuples that are suitable for pushing straight into John the Ripper (simply save one or more hashes to a file and then run <code class="language-plaintext highlighter-rouge">john $FILE</code>).</p>
<p>That said, basically this was all the same as running:</p>
<pre><code class="language-mysql">SELECT Host,
User,
authentication_string,
password_expired,
account_locked
FROM mysql.user\G
</code></pre>
<p>NOTE: John the Ripper records cracked hash:password tuples in ~/.john/john.pot, and then references this file to avoid cracking known hashes. It <em>doesn’t</em> output these passwords again (instead simply declaring “[n]o password hashes left to crack”), so if you get no output then you’ll want to just grep for your hash in john.pot.</p>
<h2 id="web-fundamentals">Web Fundamentals</h2>
<h3 id="how-do-we-load-websites">How Do We Load Websites?</h3>
<p>Different request types in HTTP are called “verbs”.</p>
<h3 id="more-http-verbs-and-request-formats">More HTTP: Verbs and Request Formats</h3>
<p>HTTP “verbs” are also called “methods”, which is a term I’m more familiar with. There are 9 total methods, but the most common are GET (retrieve data) and POST (send data).</p>
<p>All HTTP requests begin with a line of the form <code class="language-plaintext highlighter-rouge">$METHOD $SERVER_PATH $OPTIONAL_PROTOCOL VERSION</code> (for example, <code class="language-plaintext highlighter-rouge">GET /index.html HTTP/1.1</code>). Request bodies are permitted for all methods, but are normally ignored for GET (really only the headers matter for GET).</p>
<p>HTTP responses start out with the line <code class="language-plaintext highlighter-rouge">$PROTOCOL_VERSION $RESPONSE_CODE $OPTIONAL_SERVER_DEFINED_MESSAGE</code> (for example, <code class="language-plaintext highlighter-rouge">HTTP/1.1 200 OK</code>).</p>
<p>HTTP response codes:</p>
<table>
<thead>
<tr>
<th style="text-align: center">Block</th>
<th style="text-align: left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">100 - 199</td>
<td style="text-align: left">Informational response (uncommon).</td>
</tr>
<tr>
<td style="text-align: center">200 - 299</td>
<td style="text-align: left">Success</td>
</tr>
<tr>
<td style="text-align: center">300 - 399</td>
<td style="text-align: left">Redirects</td>
</tr>
<tr>
<td style="text-align: center">400 - 499</td>
<td style="text-align: left">Client errors (problems with the request content)</td>
</tr>
<tr>
<td style="text-align: center">500 - 599</td>
<td style="text-align: left">Server errors (problems with processing the request)</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">HTTP response status codes</a></li>
</ul>
<h3 id="mini-ctf">Mini CTF</h3>
<p>Useful cURL flags:</p>
<ul>
<li><code class="language-plaintext highlighter-rouge">-v</code> — show full transaction, including headers (not just response bodies).</li>
<li><code class="language-plaintext highlighter-rouge">--data "$DATA"</code> — send $DATA as the request body.</li>
<li><code class="language-plaintext highlighter-rouge">--cookie "$&#x007b;COOKIE_NAME&#x007d;=$&#x007b;COOKIE_VALUE&#x007d;"</code> — send a cookie.</li>
</ul>