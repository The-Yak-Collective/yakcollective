---
title: 'TryHackMe: Complete Beginner'
date: 2021-10-07 12:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2021-10-07-tryhackme-complete-beginner.html
author: 100007
---

<h1 id="tryhackme-complete-beginner">TryHackMe: Complete Beginner</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2021-10-07</p>
<h1 id="owasp-top-10">OWASP Top 10</h1>
<h2 id="severity-09-components-with-known-vulnerabilities">(Severity 09) Components With Known Vulnerabilities</h2>
<p>The trickiest part of this is that the project is called “CSE Bookstore”, but the exploit code in ExploitDB is listed under “Online Book Store”.</p>
<p>The actual vulnerability is two-fold:</p>
<p>(1) Admin image uploads bypass authentication.</p>
<p>(2) There’s no check on <em>what</em> actually gets uploaded, so we can push up a PHP script instead of an actual image.</p>
<ul>
<li><a href="https://www.exploit-db.com/exploits/47887">Online Book Store 1.0 - Unauthenticated Remote Code Execution</a></li>
</ul>
<h1 id="owasp-juice-shop">OWASP Juice Shop</h1>
<h2 id="ah-dont-look">AH! Don’t Look!</h2>
<p>Finally, a useful piece of general knowledge.</p>
<p>Some languages use null bytes to know when a string terminates, rather than tracking the actual string length (it looks like PHP is one of these). If a null byte (generally? always? encoded as <code class="language-plaintext highlighter-rouge">%00</code>) is included in a string, then everything after that byte is dropped by the interpreter.</p>
<p>Because % characters are themselves special, null bytes need to be encoded in URLs as <code class="language-plaintext highlighter-rouge">%2500</code>.</p>
<p>Typically a null byte will either be inserted at the end of a string (to prevent a common suffix from being appended, which can sometimes allow us to exfiltrate files we wouldn’t otherwise have access to) or before a “fake” file extensions (which can cause some file-type checks to pass, again allowing us to download files we’d otherwise be denied access to).</p>
<p>The best way to defend against these attacks is to simply sanitize strings by explicitly removing any null bytes they contain.</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$sanitized_string</span> <span class="o">=</span>
<span class="nb">str_replace</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s1">''</span><span class="p">,</span> <span class="nv">$original_string</span><span class="p">);</span>
</code></pre></div></div>
<p><a href="https://defendtheweb.net/article/common-php-attacks-poison-null-byte">Defend the Web has a much better description of what’s going on here than the one offered by TryHackMe.</a></p>
<h2 id="whos-flying-this-thing">Who’s Flying This Thing?</h2>
<p>Broken access control vulnerabilities can be classified into one of two types:</p>
<ul>
<li>HORIZONTAL privilege escalation allows the attacker to perform actions as a different user with the <em>same</em> permissions they currently have.</li>
<li>VERTICAL privilege escalation allows the attacker to perform actions as a different user with <em>higher</em> permissions then they currently have.</li>
</ul>
<p>Mostly this section seems to be driving home that one should look everywhere for clues (in the present case, there’s clues about hidden parts of the site structure in some of the JavaScript files loaded with the page), and also that accessing sensitive information (for example, through URL enumeration) doesn’t necessarily <em>look</em> like accessing “new” information (in the OWASP Juice Shop, accessing another user’s shopping car can be done without actually changing the header that says it’s “your” shopping cart).</p>
<h2 id="where-did-that-come-from">Where Did That Come From?</h2>
<p>In addition to the <code class="language-plaintext highlighter-rouge">&lt;script/&gt;</code> tag, it’s also possible to inject JavaScript using the <code class="language-plaintext highlighter-rouge">&lt;iframe/&gt;</code> tag by setting the <code class="language-plaintext highlighter-rouge">src</code> attribute to the <code class="language-plaintext highlighter-rouge">javacript:</code> pseudo-protocol. For example:</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;iframe</span> <span class="na">src=</span><span class="s">"javascript:alert('XSS');"</span><span class="nt">/&gt;</span>
</code></pre></div></div>
<p>It’s worth noting that JavaScript also accepts back-ticks as a type of quotation mark, so we actually have three different marks to work with (single quote, double quote, and back-tick).</p>
<p>A useful HTTP header to know about: <code class="language-plaintext highlighter-rouge">True-Client-IP</code> supplies an override for the client IP address to the server (similar to <code class="language-plaintext highlighter-rouge">X-Forwarded-For</code> with proxies).</p>
<p>The lesson of this section: Don’t trust any user input, even HTTP headers!</p>
<p>As a side-note, these examples really aren’t showing me much of the value of XSS attacks. I can see where they would be useful for targeting <em>users</em> (malicious links, etc.), and from that I can see where they would be useful when targeting, say, admins… But there really isn’t a way they can <em>directly</em> compromise the server or webapp (which makes sense, as JavaScript runs on the client, not the server).</p>