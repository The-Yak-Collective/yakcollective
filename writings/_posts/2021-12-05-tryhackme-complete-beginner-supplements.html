---
title: 'TryHackMe: Complete Beginner (Supplements)'
date: 2021-12-05 06:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2021-12-05-tryhackme-complete-beginner-supplements.html
author: 100007
---

<h1 id="tryhackme-complete-beginner-supplements">TryHackMe: Complete Beginner (Supplements)</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2021-12-05</p>
<h2 id="attacking-kerberos">Attacking Kerberos</h2>
<h3 id="introduction">Introduction</h3>
<p>Kerberos: The default authentication method for Windows domains. Intended to be the successor to NTLM.</p>
<ul>
<li>TICKET GRANTING TICKET (TGT): An authentication ticket that can be used to request service tickets for specific domain services from the ticket granting service.</li>
<li>KEY DISTRIBUTION CENTER (KDC): A domain service that issues tickets; typically composed of the ticket granting service and the authentication service.</li>
<li>AUTHENTICATION SERVICE (AS): Issues ticket granting tickets. (Presumably in charge of <em>authenticating</em> users and automations.)</li>
<li>TICKET GRANTING SERVICE (TGS): Issues tickets for domain services (and machines?) when presented with a ticket granting ticket. (Presumably in charge of <em>authorizing</em> users and automations.)</li>
<li>SERVICE PRINCIPAL NAME (SPN): A service identifier. On Windows, SPNs associates a particular service instance with a domain account. All services must have a domain service account. (But it sounds like services might be associated with <em>multiple</em> accounts via multiple principal names assigned to multiple running instances?)</li>
<li>KDC LONG TERM SECRET KEY (KDC LT KEY): A secret key used to encrypt ticket granting tickets and sign privilege attribute certificates. This is the NT hash of the KRBTGT service account.</li>
<li>SERVICE LONG TERM SECRET KEY (SERVICE LT KEY): A secret key associated with a particular service. Used to encrypt the service portion of a service ticket and sign privilege attribute certificates. Held by individual domain service accounts.</li>
<li>SESSION KEY: Issued with a ticket to identify a particular user session. Services expects <em>both</em> a ticket and a session key to be present before acting on a user’s behalf.</li>
<li>PRIVILEGE ATTRIBUTE CERTIFICATE (PAC): A bundle of the user’s identifying information, which is provided along with the tickets. Importantly, this contains the user’s username and (on Windows) SID.</li>
</ul>
<p>Much acronym. Very Microsoft.</p>
<p>I found TryHackMe’s discussion of Kerberos authentication pretty confusing, but Wikipedia’s walk-through of the authentication process is much clearer. The below steps are cut-and-pasted from Wikipedia’s walk-through, but with language adapted to match the Windows-specific environment TryHackMe is concerned with…</p>
<p>[α] Client Authentication to the KDC (a.k.a. “Pre-Authentication”):</p>
<p>(1) AS-REQ: The client sends the client/user ID + the current timestamp (the timestamp is used to prevent replay attacks) encrypted with the NT hash of the user’s password a cleartext message of the user ID to the authentication server to request services on behalf of the user.</p>
<p>(2) AS-REP: The authentication server checks to see if the client/user ID is in its database and if it can decrypt the timestamp using the NT hash of the password stored there. If it can, then the authentication server sends back the following two messages to the client:</p>
<ul>
<li>Message A: <em>Client/TGS Session Key</em> encrypted using the NT hash of the client/user.</li>
<li>Message B: <em>Ticket Granting Ticket</em> (including the privilege attribute certificate, client network address, ticket validity period, and the <em>Client/TGS Session Key</em>) encrypted using the KDC long term secret key.</li>
</ul>
<p>(3) Once the client receives messages A and B, it attempts to decrypt message A with the NT hash generated from the password entered by the user. If the user entered password does not match the password in the authentication service database then decryption of message A will fail. Once message A is decrypted, the client obtains the <em>Client/TGS Session Key</em>. This session key is used for further communications with the ticket granting service. (Note: The client cannot decrypt Message B, as it is encrypted using the KDC long term secret key.)</p>
<p>[β] Client Service Authorization:</p>
<p>(1) TGS-REQ: When requesting services, the client sends the following messages to the ticket granting service:</p>
<ul>
<li>Message C: Composed of the ticket granting ticket and the service principal name of the requested service.</li>
<li>Message D: Authenticator (which is composed of the client ID and the timestamp), encrypted using the <em>Client/TGS Session Key</em>.</li>
</ul>
<p>(2) TGS-REP: Upon receiving messages C and D, the ticket granting service retrieves the ticket granting ticket out of message C and decrypts it using the KDC long term secret key. This gives it the <em>Client/TGS Session Key</em> and the client ID (the client ID is part of the privilege attribute certificate). Using the <em>Client/TGS Session Key</em>, the ticket granting service decrypts message D (Authenticator) and compares the client IDs from the ticket granting ticket and message D; if they match, the server sends the following two messages to the client:</p>
<ul>
<li>Message E: <em>Service ticket</em> (which includes the privilege attribute certificate, client network address, validity period, and <em>Client/Server Session Key</em>) encrypted using the service’s long term secret key.</li>
<li>Message F: <em>Client/Server Session Key</em> encrypted with the <em>Client/TGS Session Key</em>.</li>
</ul>
<p>[γ] Client Service Access:</p>
<p>(1) AP-REQ: Upon receiving messages E and F from ticket granting service, the client has enough information to authenticate itself to the service server. The client connects to the service server and sends the following two messages:</p>
<ul>
<li>Message E: The <em>service ticket</em> (as provided by the ticket granting service; see above).</li>
<li>Message G: A new Authenticator, which includes the client ID, timestamp and is encrypted using <em>Client/Server Session Key</em>.</li>
</ul>
<p>(2) AP-REP: The service server decrypts the service ticket (message E) using its long term secret key to retrieve the <em>Client/Server Session Key</em>. Using the sessions key, it then decrypts the Authenticator and compares client ID from the service ticket and message G. If they match the server sends the following message to the client to confirm its true identity and willingness to serve the client:</p>
<ul>
<li>Message H: The timestamp found in client’s Authenticator (sometimes modified, depending upon the version of Kerberos being used), encrypted using the <em>Client/Server Session Key</em>.</li>
</ul>
<p>(3) The client decrypts the confirmation (message H) using the <em>Client/Server Session Key</em> and checks whether the timestamp is correct. If so, then the client can trust the server and can start issuing service requests to the server.</p>
<p>(4) The server provides the requested services to the client.</p>
<p>Tickets are typically base64-encoded.</p>
<p>The above process explains why it’s sometimes said that “a hash is as good as a password” for a Window’s domain.</p>
<ul>
<li><a href="https://cardboard-iguana.com/notes/windows-password-hashes.html">Windows Password Hashes</a></li>
<li><a href="https://blog.quest.com/golden-ticket-attacks-how-they-work-and-how-to-defend-against-them/">Golden ticket attacks: How they work — and how to defend against them</a></li>
<li><a href="https://tryhackme.com/room/attackingkerberos">TryHackMe: Attacking Kerberos</a></li>
<li><a href="https://en.wikipedia.org/wiki/Kerberos_%28protocol%29#Description">Kerberos (protocol) (Wikipedia)</a></li>
</ul>
<h3 id="enumerating-with-kerbrute">Enumerating with Kerbrute</h3>
<p>Kerbrute works by sending a single UDP packet to the authentication service to begin the authentication process, but then doesn’t complete the transaction as to avoid an actual login failure (and the associated logging). While this doesn’t grant access to anything, it does allow domain users to be enumerated using a wordlist.</p>
<p>NOTE: To use kerbrute you need to already be on the domain you are attacking, or alternately need to have mapped the domain controller (which normally hosts the KDC) IP address properly in your /etc/hosts file.</p>
<h3 id="harvesting--brute-forcing-tickets-with-rubeus">Harvesting &amp; Brute-Forcing Tickets with Rubeus</h3>
<p>Rubeus is a Windows-only post-exploitation tool for attacking Kerberos. No compiled binaries are available (either through the GitHub repo or Kali Linux’s <code class="language-plaintext highlighter-rouge">windows-binaries</code> package).</p>
<p>NOTE: To use Rebueus you need to already be on the domain you are attacking, or alternately need to have mapped the domain controller (which normally hosts the KDC) IP address properly in C:/Windows/System32/drivers/etc/hosts.</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Harvest ticket granting tickets observed by the current</span><span class="w">
</span><span class="c"># machine. Probably works best when run on a domain</span><span class="w">
</span><span class="c"># controller.</span><span class="w">
</span><span class="c">#</span><span class="w">
</span><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">harvest</span><span class="w"> </span><span class="nx">/interval:30</span><span class="w">
</span><span class="c"># Spray the specified password across all known users and</span><span class="w">
</span><span class="c"># generate a ticket giving ticket for successful</span><span class="w">
</span><span class="c"># authentications. (Can trigger account lockouts!)</span><span class="w">
</span><span class="c">#</span><span class="w">
</span><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">brute</span><span class="w"> </span><span class="nx">/password:ThePasswordToSpray</span><span class="w"> </span><span class="nx">/noticket</span><span class="w">
</span></code></pre></div></div>
<ul>
<li><a href="https://github.com/GhostPack/Rubeus">Rubeus</a></li>
</ul>
<h3 id="kerberoasting">Kerberoasting</h3>
<p>Kerberoasting is where a service ticket is used to brute force a service password. This password can then be used to either move laterally or (if the service runs with elevated privileges) to elevate your privileges.</p>
<p>Note that not every account is kerberoastable, though it’s not 100% obvious from this walk-through why that is. The Kali Linux tool <code class="language-plaintext highlighter-rouge">bloodhound</code> can be used to identify potentially kerberoastable accounts.</p>
<p>The main defenses against kerberoasting are (1) strong passwords and (2) making sure you’re not running any services as domain admin (which you shouldn’t need to do in this day and age anyway).</p>
<h3 id="rubeus">Rubeus</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Extract password hashes for all known kerberoastable</span><span class="w">
</span><span class="c"># accounts using Rubeus.</span><span class="w">
</span><span class="c">#</span><span class="w">
</span><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w">
</span></code></pre></div></div>
<p>The password hashes output here can then be cracked with Hashcat (use the 13100 hash mode).</p>
<ul>
<li><a href="https://cardboard-iguana.com/notes/hashcat.html">Using Hashcat</a></li>
</ul>
<h3 id="impacket">Impacket</h3>
<p>Impacket can identify kerberoastable accounts and dump packets remotely. It comes standard with Kali Linux.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>python3 <span class="se">\</span>
/usr/share/doc/python3-impacket/examples/GetUserSPNs.py <span class="se">\</span>
<span class="k">$&#x007b;</span><span class="nv">DOMAIN</span><span class="k">&#x007d;</span>/<span class="k">$&#x007b;</span><span class="nv">USER</span><span class="k">&#x007d;</span>:<span class="k">$&#x007b;</span><span class="nv">PASSWORD</span><span class="k">&#x007d;</span> <span class="se">\</span>
<span class="nt">-dc-ip</span> <span class="nv">$DOMAIN_CONTROLLER_IP</span> <span class="nt">-request</span>
</code></pre></div></div>
<p>The password hashes output here can then be cracked with Hashcat (use the 13100 hash mode).</p>
<ul>
<li><a href="https://cardboard-iguana.com/notes/hashcat.html">Using Hashcat</a></li>
</ul>
<h3 id="as-rep-roasting-with-rubeus">AS-REP Roasting with Rubeus</h3>
<p>AS-REP roasting is basically kerberoasting for regular user accounts. The only requirement to roast a user account is that Kerberos pre-authentication is disable.</p>
<p>(When pre-authentication is disabled, the authentication server will supply a ticket granting ticket and a session key automatically when requested, <em>without first verifying the user</em>. This data is then stored offline by the Windows machine for later decryption when the user with pre-authentication disabled logs in. But this means that all we need to do is to break the user’s NT hash!)</p>
<p>Both Rubeus and Impacket (via GetNPUsers.py) support AS-REP roasting; however, Rubeus can auto-discover roastable users, while GetNPUsers.py requires that user accounts already be enumerated and roastable accounts identified.</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># AS-REP roasting with Rubeus.</span><span class="w">
</span><span class="c">#</span><span class="w">
</span><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">asreproast</span><span class="w">
</span></code></pre></div></div>
<p>To use Hashcat to crack the hashes obtained in this fashin, first insert <code class="language-plaintext highlighter-rouge">23$</code> after the leading <code class="language-plaintext highlighter-rouge">$kerb5asrep$</code> (so <code class="language-plaintext highlighter-rouge">$kerb5asrep$</code> → <code class="language-plaintext highlighter-rouge">$kerb5asrep$23$</code>) and then use mode 18200.</p>
<p>Basically the only mitigation for this attack is to keep pre-authentication enabled, though strong password policies can help.</p>
<ul>
<li><a href="https://cardboard-iguana.com/notes/windows-password-hashes.html">Windows Password Hashes</a></li>
<li><a href="https://cardboard-iguana.com/notes/hashcat.html">Using Hashcat</a></li>
</ul>
<h3 id="pass-the-ticket-with-mimikatz">Pass the Ticket with Mimikatz</h3>
<p>Mimikatz can dump ticket granting tickets (and session keys?) from the memory of Windows’ Local Security Authority Subsystem Service (LSASS); these can then be used to for privilege elevation or lateral movement (depending on which users are active on that machine).</p>
<p>NOTE: There’s a bit of terminology creep in these discussions. Mimikatz and Rubeus are actually dumping Kerberos data structures (as .kirbi files), which contain <em>both</em> a ticket <em>and</em> the corresponding session key. People tend to call these .kirbi files “tickets”, but it’s worth keeping in mind that they contain <em>both</em> pieces of data (as a “ticket” in the Kerberos sense, not the hacker’s sense, isn’t useful without the corresponding session key). See “Rubeus — Now With More Kekeo” for a good discussion of this.</p>
<p>Mimikatz needs to be run with administrative privileges (on the local machine), and provides its own command prompt.</p>
<ul>
<li><code class="language-plaintext highlighter-rouge">privilege::debug</code> — See if you’re running with the right privileges.</li>
<li><code class="language-plaintext highlighter-rouge">sekurlsa::tickets /export</code> — Dump any Kerberos ”tickets” (really ticket + session key data structures) from LSASS’s memory as .kirbi files. Tickets are named like ID-USER-SERVICE-DOMAIN.kirbi; ticket granting tickets have a <code class="language-plaintext highlighter-rouge">krbtgt</code> SERVICE name. If you can find a <code class="language-plaintext highlighter-rouge">krbtgt</code> ticket belonging to an administrator account, then you’ve struck gold (literally — see the next section).</li>
<li><code class="language-plaintext highlighter-rouge">kerberos::ptt TICKET_FILE</code> — Load the data structure in the specified .kirbi file into memory (allowing the account you’re logged in as to “pass the ticket” and impersonate the user whose ticket you’ve harvested).</li>
</ul>
<p>The built-in Windows command <code class="language-plaintext highlighter-rouge">klist</code> will show you the current Kerberos tickets in memory.</p>
<p>The only real way to defend against this attack is to <em>only</em> allow domain admins to log into domain controllers, <em>not</em> lower privileged machines!</p>
<ul>
<li><a href="http://www.harmj0y.net/blog/redteaming/rubeus-now-with-more-kekeo/">Rubeus — Now With More Kekeo</a></li>
</ul>
<h3 id="goldensilver-ticket-attacks-with-mimikatz">Golden/Silver Ticket Attacks with Mimikatz</h3>
<p>The idea with gold and silver tickets is that, since the KDC and service long term secret keys are just the NT hashes of the corresponding service account’s passwords, then if you can dump the password (or even its hash), you can <em>forge</em> a kerberos ticket without ever needing to contact the KDC. (See “Silver &amp; Golden Tickets”.)</p>
<p>Silver tickets are forged using a service account’s NT hash, and can be used to grant any user access to that service. This works because Kerberos implicitly assumes that <em>only</em> the KDC and the service account know the service account’s long term secret key.</p>
<p>Golden tickets take things a step further — if you can get the <code class="language-plaintext highlighter-rouge">krbtgt</code> <em>user</em>’s NT hash, then you can forge a ticket granting ticket for any user, and then use that to get the KDC to provide a valid service ticket for any service that user has access to. This works because Kerberos trusts the encrypted ticket granting ticket blob and <em>doesn’t reauthenticate the user before granting further access</em>.</p>
<p>Golden tickets are powerful (since you can be anyone, it’s trivial to gain control of the domain), but also noisier — because you’re running through the KDC infrastructure, golden ticket still generate (almost) all of the normal logging, while silver tickets allow you to bypass the KDC completely and only generate logs on the service server (if that).</p>
<p>To generate a gold or silver ticket using Mimikatz, begin by running the <code class="language-plaintext highlighter-rouge">lsadump::lsa /inject /name:SERVICE</code> command to retrieve the service SID and NTLM password hash for that service. If SERVICE is <code class="language-plaintext highlighter-rouge">krbtgt</code> then this will allow the creation of a golden ticket, otherwise you’ll be creating a silver ticket.</p>
<p>(You can also use a user name instead of SERVICE, in which case it appears that Mimikatz will just request a ticket granting ticket from the KDC as that user in the next step; this is theoretically just as noisy as a golden ticket, but looks more “normal”.)</p>
<p>To actually create and cache the ticket, use <code class="language-plaintext highlighter-rouge">Kerberos::golden /user:USER /domain:DOMAIN /sid:SID /krbtgt:HASH /id:TYPE</code>, where:</p>
<ul>
<li><code class="language-plaintext highlighter-rouge">USER</code> is the user to create the ticket for (probably the one you’ve compromised).</li>
<li><code class="language-plaintext highlighter-rouge">DOMAIN</code> is the domain to create the ticket for.</li>
<li><code class="language-plaintext highlighter-rouge">SID</code> is the SID of the service from the previous step.</li>
<li><code class="language-plaintext highlighter-rouge">HASH</code> is the NT hash of the service password from the previous step.</li>
<li><code class="language-plaintext highlighter-rouge">TYPE</code> is the type of Kerberos ticket to create; use 500 for a golden (ticket granting) ticket, and 1103 for a service ticket.</li>
</ul>
<p>Once the ticket has been created, use <code class="language-plaintext highlighter-rouge">misc::cmd</code> to open a command prompt using the newly forged ticket.</p>
<ul>
<li><a href="https://cardboard-iguana.com/notes/windows-password-hashes.html">Windows Password Hashes</a></li>
<li><a href="https://en.hackndo.com/kerberos-silver-golden-tickets/">Silver &amp; Golden Tickets</a></li>
</ul>
<h3 id="kerberos-backdoors-with-mimikatz">Kerberos Backdoors with Mimikatz</h3>
<p>If Mimikatz is run on a domain controller, it can modify the authentication service’s memory using the <code class="language-plaintext highlighter-rouge">misc::skeleton</code> command to cause it to attempt to decrypt the AS-REQ using <em>both</em> the user’s NT hash <em>and</em> an NT hash of your choosing (by default <code class="language-plaintext highlighter-rouge">60BA4FCADC466C7A033C178194C03DF6</code>, which is just <code class="language-plaintext highlighter-rouge">mimikatz</code>). This means that you can send an AS-REQ as any user using the “skeleton key” hash to gain access as that user, similar to a golden ticket attack.</p>
<p>Obviously this isn’t very persistent itself, as the skeleton key will be lost if the server is rebooted or the authentication service restarted.</p>
<ul>
<li><a href="https://cardboard-iguana.com/notes/windows-password-hashes.html">Windows Password Hashes</a></li>
</ul>