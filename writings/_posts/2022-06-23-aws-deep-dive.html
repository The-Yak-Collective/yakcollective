---
title: AWS Deep Dive
date: 2022-06-23 05:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2022-06-23-aws-deep-dive.html
author: 100007
---

<h1 id="aws-deep-dive">AWS Deep Dive</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2022-06-23</p>
<h2 id="deep-dive-on-amazon-s3-security-and-management">Deep Dive on Amazon S3 Security and Management</h2>
<h3 id="s3-access-control-mechanisms">S3 Access Control Mechanisms</h3>
<p>By default, S3 buckets are only accessible by the owner</p>
<p>Available access control mechanism:</p>
<ul>
<li>IAM — Best when dealing with internal Amazon users/systems. Controls access from the <em>user’s</em> perspective.</li>
<li>S3 Bucket Policy — Uses the same JSON structure as IAM. Controls access from the <em>bucket’s</em> perspective. Need to be used for cross-account authentication.</li>
<li>S3 ACLs — XML-based. Can only <em>add</em> access. “Full Control” is used for cross-account access.</li>
<li>VPC Endpoints — Use a VPC endpoint as a proxy, and then restrict access using VPC policies. Allows bucket <em>content</em> to be exposed externally without exposing the entire bucket.</li>
<li>Pre-Signed URLs — Basically, special URLs that can perform pre-defined actions. <em>Anyone who can access this URL can perform these actions.</em></li>
</ul>
<p>IAM <em>authentication</em> is handled by the account itself, but <em>authorization</em> is handled on a service-by-service basis.</p>
<h3 id="s3-block-public-access">S3 Block Public Access</h3>
<p>This is a set of security controls that blocks unrestricted (“public”) non-cross-account access, overriding (depending on the use case) existing permissions. There are four controls, each of which can be applied separately:</p>
<ul>
<li><em>Block</em> new public ACLs and objects</li>
<li><em>Remove</em> existing public access granted by ACLS</li>
<li><em>Block</em> all new public bucket policies</li>
<li>Block public <em>and</em> cross-account access to public buckets</li>
</ul>
<p>The last of these is intended to be an intermediate state allowing a bucket to be temporarily locked down while public policies are removed or restricted.</p>
<p>These four policies can be applied in any combination at either the account (which applies to all buckets) or per-bucket level. When applied at the account level, new buckets will automatically inherit these policies. (Note that when new buckets are created on the console these settings are all selected by default, even if these policies have <em>not</em> been applied. These can be thought of as “safe defaults”. <em>However</em>, if the policies are not applied at the account level, then buckets created via the API will <em>not</em> be protected by default!)</p>
<h3 id="how-s3-authorizes-a-request">How S3 Authorizes a Request</h3>
<p>When S3 is checking authorization, it rolls up all applicable policies and then considers them as a single “master” policy. There are (conceptually) three stages to this check:</p>
<ul>
<li>User context (has the user been granted explicit access).</li>
<li>Bucket context (has the bucket owner granted the user authorization to perform a particular action).</li>
<li>Object context (does the object ACL grant access).</li>
</ul>
<p>S3 starts by checking for an <em>explicit</em> deny, and if one exists evaluation stops and the action is denied. A check is then made for an explicit <em>allow</em>, and if one exists evaluation stops and the action is allowed. If neither an explicit deny or allow are found, then the action/user is <em>implicitly</em> denied.</p>
<p>Interestingly, by default bucket ownership does <em>not</em> grant object ownership. So in a cross-account situation, objects uploaded by one account to a bucket owned by another account are <em>not</em> readable by the bucket owner unless an ACL exists for the object providing that permission. Object-level permissions <em>cannot</em> be changed at the bucket level. (To allow other bucket users to view uploaded objects, either the object owner must either add the users to the object ACL or add a role controlled by the bucket owner that other users can assume.)</p>
<h3 id="s3-encryption">S3 Encryption</h3>
<p>Encryption keys can be managed directly in S3, via AWS KMS, using client-managed keys, or entirely client-side.</p>
<p>It sounds like encryption is done using symmetric keys, at least in the KMS case. However, the key itself is encrypted by KMS. The encrypted key is then stored alongside the encrypted object, and handed back to KMS for decryption when the object is retrieved (this creates an additional layer of authorization, as KMS is <em>also</em> checking to see if decryption operations are authorized). I think the idea here is to enable per-object keys but still use a single “source of truth” for decryption authorization.</p>
<h3 id="use-cases">Use Cases</h3>
<p>It turns out that Capitol One wrote a similar anti-ACL policy before AWS introduced the security features discussed above. One trick they used was to add an explicit “deny all” with the condition that the user was <em>not</em> within Capitol One’s AWS organization.</p>
<p>A good use case here for when to use AssumeRole, but it’s kind of reverse what Amazon was describing: Capitol One’s high-security systems will do an AssumeRole to push lower security data into a segmented low-security system. Doing that means that data being placed into low-security S3 buckets is put there <em>by the low-security account</em> (whose role the high-security account has assumed). This allows the low-security account to then manage access to that data without the high-security account ever needing to interact with or know about downstream object consumers. This also gets Capitol One out of having to manage ACLs <em>entirely</em>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://youtu.be/x25FSsXrBqU">AWS re:Invent 2018: Deep Dive on Amazon S3 Security and Management (YouTube)</a></li>
</ul>
<h2 id="become-an-iam-policy-master-in-60-minutes-or-less">Become an IAM Policy Master in 60 Minutes or Less</h2>
<h3 id="iam-policy-language">IAM Policy Language</h3>
<p>Basic IAM policy structure: “PARC” — Principal, Action, Resource, Condition. This is all led by an initial “effect”, which is allow/deny.</p>
<ul>
<li>Principal — the entity with is allowed/denied access.</li>
<li>Action — the type of access being allowed/denied.</li>
<li>Resource — what the action is working on.</li>
<li>Condition — <em>when</em> should the policy be enforced.</li>
</ul>
<p>I’m guessing that the “default” condition is <code class="language-plaintext highlighter-rouge">*</code>, since I’ve seen IAM policies without conditions.</p>
<p>A non-standard way to think about policy evaluation: It’s all about matching. (Does the incoming policy, which may include AWS-populated data, match a policy defined by the account? If so, then execute that policy, deny before allow. If not, then just deny.)</p>
<h3 id="policy-types--interactions">Policy Types &amp; Interactions</h3>
<p>It sounds like AWS Organizations are basically just another policy layer on top of (and overriding?) regular accounts. In particular, these policies seem to be more geared towards controlling access to entire services (can a particular account even <em>use</em> S3 or EC2) more than user- or role-level permissioning. These “service control policies” are default deny, just like everything else in AWS, but all new accounts/organizations are provisioned with an explicit “allow everything” service control policy initially.</p>
<p>IAM has the concept of a “permission boundary”, which are defined <em>maximum</em> permission sets <em>within</em> an account.</p>
<p>”STS” in AWS stands for “Security Token Service”.</p>
<p>In general, you need an IAM policy <em>or</em> a resource-based policy to access something within an account. For cross-account access <em>both</em> the IAM and resource-based policies must be present and aligned.</p>
<h3 id="policy-use-cases">Policy Use Cases</h3>
<p>The recommendation here when using service control policies at the organization level is to blacklist, rather than whitelist, things. That’s kind of reverse from the normal way of doing things, and seems to mostly be motivated by the sheer number of services (and the growth rate of that number) that AWS supports.</p>
<p>When scoping service control policies by region, note that a handful of services (and actions within some otherwise normal services) that are <em>globally</em> scoped. That means that <em>denying</em> a region will not always have the effect you want! (I assume this means we should deny globally and then allow in specific regions in this case, opposite of the previous advice.)</p>
<p>You can do some cool things with IAM and service control policies, like <em>requiring</em> that developer-created roles include a permission boundary or region.</p>
<p>Policies actually support some limited variables: For example, <code class="language-plaintext highlighter-rouge">$&#x007b;aws:PrincipalTag/project&#x007d;</code> let’s you reference user (“principal”) tags within a policy condition. This lets you, for example, require that developers always tag resources they create with a pre-assigned (role?) tag (you can also restrict the ability of developers to <em>control</em> resources that don’t share their tag). This sort of generality comes in handy if you have a lot of teams that have the <em>same</em> permission structure but need to be siloed from each other — write <em>one</em> policy (or set of policies), and then tag the associated users/groups/roles to apply that policy in an <em>identical but disjoint</em> fashion.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://youtu.be/YQsK4MtsELU">AWS re:Invent 2018: Become an IAM Policy Master in 60 Minutes or Less (YouTube)</a></li>
</ul>