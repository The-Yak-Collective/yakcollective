---
title: A New HOPE
date: 2022-07-24 12:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2022-07-24-a-new-hope.html
author: 100007
---

<h1 id="a-new-hope">A New HOPE</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2022-07-24</p>
<p>Notes for the final day of A New HOPE.</p>
<h1 id="4th-track-matrix">(4th Track) Matrix</h1>
<p>The Matrix project requires spec changes to be presented along with a <em>working</em> implementation. The non-profit Matrix Foundation stewards the specification.</p>
<p>Rooms can be grouped in a hierarchical fashion using “spaces”. Spaces can include highlighted/recommended rooms, and can be restricted by invite, user, server, or domain.</p>
<p>What’s coming next:</p>
<ul>
<li>Performance improvements (especially room joining, as key exchange can be slow)</li>
<li>True P2P (a Matrix server on your phone, probably using the Go-based Dendrite)</li>
<li>“Metaverse” support (called “third room” - VR extensions; a little unclear what this means)</li>
<li>GDPR compliance</li>
</ul>
<p>There seem to be hints here that the EU directive to force chat interoperability may result in broader Matrix support. (Whether this is because there’s already discussions, or because Matrix is the most advanced federated messaging spec right now, is unclear…)</p>
<p>The Synapse server is considered “legacy” at this point; Dendrite is the future, though it’s not ready for prime-time yet.</p>
<p>Matrix uses a double-ratchet protocol modeled after Signal. For P2P Matrix, there’s a (planned?) capability to allow clients approved by a user to exchange encryption keys. Keys can <em>optionally</em> be stored on a server using password-based or public key encryption.</p>
<p>Apparently the different versions of Element don’t share any code currently, though there’s a move to break out client functionality into a Rust library that will be shared (at least on mobile/desktop; not clear how this works for the web). There’s a lot of work focusing on mobile right now.</p>
<ul>
<li><a href="https://matrix.org">Matrix</a></li>
</ul>
<h1 id="electronic-warfare-on-a-budget-of-15-or-so">Electronic Warfare on a Budget of $15, or So</h1>
<p>The ideal antenna for catching a particular radio frequency has a length equal to the wavelength of that frequency. The next best length is 1/2 the wavelength, then 1/4 the wavelength, then 1/8 the wavelength, and so on.</p>
<p>Remember that lower frequencies have lower maximum data rates, since you’re limited to <em>at most</em> one bit per cycle. ELF and ULF transmissions have maximum data transmission rates measured in <em>baud</em>.</p>
<p>Unidirectional jamming is energy-prohibitive, so most jamming is directional. But the source of directional jamming can be detected using directional antennae, which is obviously is useful for targeting attacks.</p>
<p>A general approach to avoid both jamming and hide transmissions is frequency hopping. The general approach here is similar to data encryption (which should <em>also</em> be used) with a pre-shared key, where the “ciphertext” is not ones-and-zeros, but rather the “base” frequency of the radio transmission.</p>
<p>It’s possible to use the GPIO pins on a Raspberry Pi as an SDR. But be careful - without a band-pass filter, it’s really easy to run afoul of the law / FCC regulations.</p>
<p>Two versions of Postel’s Law (the “robustness principle”):</p>
<blockquote>
<p>Be conservative in what you do, be liberal in what you accept from others.</p>
</blockquote>
<p>Or, in radio:</p>
<blockquote>
<p>Be conservative in what you send, be liberal in what you accept.</p>
</blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Robustness_principle">Robustness principle (Wikipedia)</a></li>
</ul>
<h1 id="programming-in-zero-knowledge">Programming in Zero Knowledge</h1>
<p>At a high level, zero knowledge proofs (ZKPs) involve a “prover” and a “verifier”. Both parties know a function F and a public input x, but only the prover knows a witness value w. The function satisfies F(x, w) = 1; the idea here is that the prover needs to convince the verifier that it knows w satisfying this <em>without</em> disclosing this value.</p>
<p>ZKPs are central to a variety of contexts - things like Zcash, but also things like TPMs and distributed protocols (Bluesky uses ZKPs on the back end). These are not actually a new thing - ZKPs originated in the 1980s.</p>
<p>A “succinct” ZKP can be verified in polynomial time. Succinct ZKPs are important for supporting low-power devices.</p>
<p>Applications:</p>
<ul>
<li>Zcash</li>
<li>RISC Zero (RISC-V in a zero knowledge context)</li>
<li>Subset-based decentralized/P2P social networks</li>
<li>zkSync and Polygon Zero (zero knowledge L2 blockchains)</li>
</ul>
<p>Parts of a ZKP:</p>
<ul>
<li>Arithmetisation - translates F and w into a low degree polynomial (we’ll be using PLONKish; other options are Groth16 and STARK);</li>
<li>Polynomial Commitment Scheme - creates a <em>probablistic</em> proof based on the evaluation of the arithmetisation on a random set of points (this is the “inner product argument”; other options are hash-based and paired-point based systems);</li>
<li>Accumulation Scheme - embeds the verifier’s identity within the proof in a recursive fashion.</li>
</ul>
<p>An example of recursion in the accumulation scheme is the Mina blockchain, which embeds the proof of correctness for the previous block within the proof of correctness of the current block. (This means that once you’ve verified the proof for the current block, you’ve <em>automatically</em> verified the entire chain’s state.)</p>
<p>The key here is that we’re not actually doing a <em>logical</em> proof, but rather a <em>probabilistic</em> proof - a set of conditions that, if satisfied, make it incredibly unlikely (but not <em>technically</em> impossible) that the witness value hasn’t been verified.</p>
<ul>
<li><a href="https://z.cash/">Zcash</a></li>
<li><a href="https://bluesky.xyz/">Bluesky</a></li>
</ul>
<h2 id="plonkish-arithmetisation">PLONKish Arithmetisation</h2>
<p>This is constructed almost like an electrical circuit, where each gate takes two inputs, adds or multiplies them, and then sends an output to the next gate.</p>
<p>PLONK requires that each gate satisfies the following condition:</p>
<blockquote>
<p>Ax + By + Cz + Dxy = 0</p>
</blockquote>
<p>A - D are pre-chosen, while x - z are the values we’re verifying. This can be decomposed into a series of “custom” gates representing addition, multiplication, and boolean truth/false:</p>
<blockquote>
<p>A (x + y - z) + B w (xy - z) + C w² (x² - x) = 0</p>
</blockquote>
<p>There are two types of “wires” connecting the gates - wires that represent witness values, and wires with values fixed by the overall system.</p>
<p>This is all done over some finite field.</p>
<p>Circuits can be represented as tables, where each column can be represented as Lagrange interpolation polynomial. Circuits can get quite large - some circuits in Zcash are up to 2²⁵ rows. Circuits can be divided into regions, which are composed of logically related gates that don’t depend on I/O from other regions.</p>
<h2 id="ultraplonk">UltraPLONK</h2>
<p>Circuits need to be linear; things like hash functions are <em>possible</em> in this context, but expensive. To get around this, UltraPLONK implements pre-computed lookup tables.</p>
<p>Lookup tables can be thought of as a generalization of permutations - instead of enforcing equality, we simply enforce inclusion in a set.</p>
<h1 id="five-dollar-cyber-weapons-and-how-to-use-them">Five Dollar Cyber Weapons and How to Use Them</h1>
<p>Apparently Chrome-based web browsers support serial connections over HTTP, and some microcontrollers (like Arduinos) can be flashed this way.</p>
<p>CircuitPython can be used on microcontrollers. After flashing the appropriate firmware, the microcontroller will appear as a USB mass storage device that Python scripts can just be written to.</p>
<p>MicroPython is an older project than CircuitPython that is not nearly as easy to use and has a lack of (recent) documentation, but supports a <em>much</em> wider range of boards.</p>
<p>Be aware that some of the ultra-cheap microcontrollers (for example, the Attiny85) are <em>so</em> cheap that they won’t always have evenly-spaced USB traces - while they might <em>look</em> like they’d work in a normal USB port, they won’t.</p>
<p>Taking a step up to something like the Atmega32u4 will <em>vastly</em> improve your experience, if just because of the manufacturing process is more reliable.</p>
<p>The ESP8266 has a lot of features (including USB and Wi-Fi) and seems to be the Swiss army knife of microcontrollers. Lots of projects for this. However, there’s not enough memory to store entire wireless packets, which limits its ability to <em>attack</em> targets (though some interception attacks are possible, and <em>surveillance</em> is eminently feasible).</p>
<p>Interesting idea: Wi-Fi network passwords are presented as hashes, and these can be harvested and then cracked offline using fake access points.</p>
<p>An ESP32 is a bit more capable than the ESP8266 (among other things, it has enough memory to actually grab full Wi-Fi packets); however, it does <em>not</em> support CircuitPython.</p>
<p>The ESP32cam contains a <em>camera</em> and can do <em>facial recognition</em>!!!</p>
<p>The ESP32s2 is the most recent version of the ESP32 and is better in almost every way… Except that the manufacturer removed the ability to send arbitrary Wi-Fi packets, so attack potential is limited.</p>
<p>The ESP32c6 is a <em>really</em> new microcontroller with a 32-bit RISC-V microprocessor! It’s so new that there’s not a lot of developer support… Yet.</p>
<ul>
<li><a href="https://circuitpython.org">CircuitPython</a></li>
<li><a href="https://micropython.org">MicroPython</a></li>
<li><a href="https://gihub.com/SpacehuhnTech/esp8266_deauther">SpacehuhnTech / esp8266_deauther</a></li>
<li><a href="https://hak5.org/">hak5</a></li>
</ul>
<h1 id="seize-the-means-of-computation-how-interoperability-can-take-the-internet-back-from-big-tech">Seize the Means of Computation: How Interoperability Can Take the Internet Back From Big Tech</h1>
<p>Cory Doctorow is advocating for a Fediverse-like approach to moderation, where communities/individuals have the power to moderate themselves as they see fit. Doctorow is open that such an approach will be fragmented and will still allow offensive speech to persist, but believes that overall such a system will be better at moderating the content that is <em>actually</em> problematic <em>for</em> that community <em>within</em> that community. (I personally reached the same conclusion a few years ago - I have no idea when Doctorow came to think this - but do think that this framing profoundly calls into question the viability/wisdom of the very <em>idea</em> that a “global community” is possible… Or even <em>desirable</em>.)</p>
<p>Interesting idea (attributed to Lawerence Lessig): There are four overlapping forms of governance - (computer) code, law, (social) norms, and markets.</p>
<ul>
<li><a href="https://craphound.com/">Cory Doctorow</a></li>
</ul>
<h1 id="a-new-hope-closing-ceremonies">A New HOPE Closing Ceremonies</h1>
<p>HOPE attendees only used ~600 Mbps of bandwidth at peak. (I wonder if this had to do with coverage. For example, I wan’t able to reliably connect to Wi-Fi in the workshop rooms; I didn’t try elsewhere, however, as I didn’t have a strong use case for networking outside of the workshops this year.)</p>
<p>There were just over 900 conference attendees this year. It’s implied that overall ticket sales were lower this year than for past HOPEs, but it sounds like there may have been a number of folks who bought tickets and then didn’t show up…</p>
<ul>
<li><a href="https://xiv.hope.net/">A New HOPE</a></li>
</ul>