---
title: AWS Deep Dive
date: 2022-08-25 12:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2022-08-25-aws-deep-dive.html
author: 100007
---

<h1 id="aws-deep-dive">AWS Deep Dive</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2022-08-25</p>
<h1 id="a-serverless-journey-aws-lambda-under-the-hood">A Serverless Journey: AWS Lambda Under the Hood</h1>
<p><a href="https://youtu.be/3qln2u1Vr2E">AWS re:Invent 2018: A Serverless Journey - AWS Lambda Under the Hood (YouTube)</a></p>
<p>Lambda is a containerized service on the backend - function code is run by workers, each of which manages multiple “sandboxes”. Workers are managed by a “worker manager”, and are recycled every 8 - 10 hours. Sandboxes are destroyed if they become idle for some period of time in order to free up resources.</p>
<p>A worker is an entire physical server.</p>
<p>In the original Lambda model, each worker ran multiple VMs, each of which contained multiple sandboxes.</p>
<p>New Lambda systems use “bare metal” EC2 virtualization, and spin up many more, smaller, VMs each of which contain a <em>single</em> sandbox (this newer architecture is reminiscent of how the Linux environment is implemented on Chromebooks).</p>
<p>Every sandbox runs only a single function over its lifetime, though multiple calls to that function may happen consecutively. On both old and new Lambda systems, VMs correspond to individual customers.</p>
<p>Control groups (cgroups) are used to enforce function memory and CPU limits (presumably some level of enforcement also happens at the VM level for newer “bare metal” Lambda systems).</p>
<p>VM devices in the newer “bare metal” VMs are all virtio based. The host-side device emulation models are themselves sandboxed, and the code itself is written in Rust.</p>
<p>Lambda concentrates load on the smallest possible number of sandboxes, rather than trying to distribute the load over many sandboxes. This makes scaling easier, and hence faster.</p>
<p>One the other hand, load (for a given type of function call) is distributed <em>evenly</em> amongst workers to prevent correlated load spikes. This is <em>not</em> to say that workers are run with partial load - rather, they have a variety of <em>kinds</em> of lambda functions (both in terms of language, complexity, and origin account) sandboxed on them. (In fact, Amazon applies some additional statistical tracking of Lambda function performance and tries to pack together functions that are <em>anti-correlated</em>.)</p>
<p>All Lambda functions exist within the current VPC. The associated network cards are actually provisioned <em>separately</em> from the Lambda functions, however, with multiple sandboxes attached to a single card using secure tunnels. This somewhat unusual setup is done to reduce startup latency, as it turns out that provisioning a new network card within a VPC is relatively expensive.</p>
<p>The AWS API gateway can call into Lambda functions for actual execution.</p>
<p>In order to optimize Lambda worker placement, one subnet should be dedicated to Lambda <em>per availability zone</em>.</p>
<h1 id="introduction-to-the-aws-cli">Introduction to the AWS CLI</h1>
<p><a href="https://youtu.be/QdzV04T_kec">AWS re:Invent 2017: Introduction to the AWS CLI (YouTube)</a></p>
<p>Order of preference for account configuration in the AWS CLI: Command line options &gt; Environment variables &gt; <code class="language-plaintext highlighter-rouge">~/.aws/credentials</code> and <code class="language-plaintext highlighter-rouge">~/.aws/config</code> files &gt; AWS container-level credentials &gt; AWS EC2-level credentials.</p>
<p>For the <code class="language-plaintext highlighter-rouge">~/.aws/*</code> files, the <code class="language-plaintext highlighter-rouge">default</code> profile will be run if no explicit profile is specified.</p>
<p>The <code class="language-plaintext highlighter-rouge">--endpoint-url</code> is used with Snowball hardware.</p>
<p>There’s an AWS “shell” available that wraps the CLI and provides tab-completion and live menus for EC2 instances, etc. Pretty cool.</p>
<p>The AWS CLI supports asking for MFA codes, and will cache the resulting authentication for the appropriate timespan. If MFA presence is required to assume a role, then the CLI will automatically prompt on <code class="language-plaintext highlighter-rouge">AssumeRole</code>.</p>
<p>The AWS CLI <code class="language-plaintext highlighter-rouge">--filter</code> option is server-side but only supported for a few commands, while the <code class="language-plaintext highlighter-rouge">--query</code> option is client-side but is supported for all commands. Both commands define searches using JMESPath.</p>
<ul>
<li><a href="https://github.com/awslabs/aws-shell">awslabs / aws-shell</a></li>
<li><a href="https://jmespath.org/">JMESPath</a></li>
</ul>